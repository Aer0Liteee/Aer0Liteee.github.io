{
    "version": "https://jsonfeed.org/version/1",
    "title": "Aer0Lite",
    "description": "",
    "home_page_url": "http://Aer0Liteee.github.io",
    "items": [
        {
            "id": "http://aer0liteee.github.io/post/dee9649a.html",
            "url": "http://aer0liteee.github.io/post/dee9649a.html",
            "title": "GNN-summary.md",
            "date_published": "2023-07-04T16:10:08.000Z",
            "content_html": "<h1 id=\"gnn\"><a class=\"markdownIt-Anchor\" href=\"#gnn\">#</a> GNN</h1>\n<h4 id=\"应用领域\"><a class=\"markdownIt-Anchor\" href=\"#应用领域\">#</a> 应用领域</h4>\n<ul>\n<li></li>\n</ul>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">场景分析与问题推理、推荐系统、欺诈检测、知识图谱、道路交通、自动驾驶、化学医疗场景......</span><br></pre></td></tr></table></figure>\n<h4 id=\"图基本模块定义\"><a class=\"markdownIt-Anchor\" href=\"#图基本模块定义\">#</a> 图基本模块定义</h4>\n<ul>\n<li>\n<img src=\"F:\\TODOIT\\GNN\\1.png\" alt=\"1\" style=\"zoom:150%;\" />\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">GNN 又称图神经网络，是一种直接作用于图结构的神经网络，我们可以把图中的每一个结点 V 当作个体对象，而每一条边 E 当作个体与个体间的某种联系，所有结点组成的关系网就是最后的图 U</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"邻接矩阵的定义\"><a class=\"markdownIt-Anchor\" href=\"#邻接矩阵的定义\">#</a> 邻接矩阵的定义</h4>\n<ul>\n<li>\n<img src=\"F:\\TODOIT\\GNN\\2.png\" alt=\"2\" style=\"zoom:50%;\" />\n<blockquote>\n<ul>\n<li>用于表示结点之间相邻的情况，由于图的稀疏性，因此一般的邻接矩阵不是一个 N*N 的矩阵，而保留了 **(source,target)** 的形式，如 [1,0] 则表示起点为 1 终点为 0。</li>\n<li>每个点通过与它相邻的<strong>邻居</strong>来进行<strong>更新</strong>，更新的方式可以自己设置。</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"适用规则\"><a class=\"markdownIt-Anchor\" href=\"#适用规则\">#</a> 适用规则</h4>\n<ul>\n<li></li>\n</ul>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">GNN主要用于解决输入数据不规则的时候，由于图像和文本任务中输入格式很固定，因此图模型并不常用，图网络和其他的神经网络类似都是需要进行特征提取</span><br></pre></td></tr></table></figure>\n<h4 id=\"消息传递方法计算\"><a class=\"markdownIt-Anchor\" href=\"#消息传递方法计算\">#</a> 消息传递方法计算</h4>\n<ul>\n<li>\n<p>每个点的特征该如何更新？</p>\n<ul>\n<li>\n<p>考虑<strong>自身</strong>的特征与<strong>邻居</strong>的特征。</p>\n</li>\n<li>\n<p><img src=\"F:%5CTODOIT%5CGNN%5C3.png\" alt=\"3\"></p>\n</li>\n<li>\n<img src=\"F:\\TODOIT\\GNN\\5.png\" alt=\"5\" style=\"zoom: 150%;\" />\n<blockquote>\n<p>​\t\t\t\t\t自身特征：<strong>h/x</strong>\t可学习参数 (相连边的权值)：<strong>W</strong></p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>\n<p>特征更新的方法有很多，可以根据任务自己设置</p>\n<ul>\n<li>\n<img src=\"F:\\TODOIT\\GNN\\4.png\" alt=\"3\" style=\"zoom:50%;\" />\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"多层gcn的作用\"><a class=\"markdownIt-Anchor\" href=\"#多层gcn的作用\">#</a> 多层 GCN 的作用</h4>\n<ul>\n<li>\n<p>GCN 可以有多层（本质即更新各部分的特征）</p>\n<p><img src=\"F:%5CTODOIT%5CGNN%5C6.png\" alt=\"6\"></p>\n</li>\n<li>\n<p>GNN 可以设置为多层结构时的<strong>输入</strong>和<strong>输出</strong>都是特征，邻接矩阵不会改变，但每个点上面的特征会发生改变。多层的 GNN 会包含更多的邻居，相当于此时的 **“感受野”**（<u>卷积神经网络名词，可理解为接触到的全局的信息范围）</u><strong>增大</strong>，当每个点具有全局的特征时，此时类似于 transformer 的形式。</p>\n</li>\n<li>\n<h5 id=\"输出特征的作用\"><a class=\"markdownIt-Anchor\" href=\"#输出特征的作用\">#</a> 输出特征的作用</h5>\n<ul>\n<li>各个点 / 边特征组合后可以进行图分类…</li>\n</ul>\n</li>\n<li>\n<h5 id=\"为什么要做多层gcn\"><a class=\"markdownIt-Anchor\" href=\"#为什么要做多层gcn\">#</a> 为什么要做多层 GCN？</h5>\n<ul>\n<li>可以使结点具有<strong>全局的特征</strong>，GCN 主要聚合邻结点的信息，对于任意一个结点，结点特征每迭代依次，就聚合了更高阶的邻结点的信息。随着 GCN 层数的增加，结点的聚合半径（最高邻居结点的阶数）也变大，一旦达到某个阈值，该结点覆盖全图结点。</li>\n<li><strong>但是</strong>，如果层数很多，每个结点覆盖的结点都会收敛到全图，这就导致每个结点的局部网络结构的多样性大大降低，对于结点自身特征的学习反而不好。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"gcn基本模型概述\"><a class=\"markdownIt-Anchor\" href=\"#gcn基本模型概述\">#</a> GCN 基本模型概述</h4>\n<ul>\n<li>适合做<strong>半监督任务</strong>，用某个结点的少量数据也能进行训练</li>\n</ul>\n<h4 id=\"图卷积的基本计算方法\"><a class=\"markdownIt-Anchor\" href=\"#图卷积的基本计算方法\">#</a> 图卷积的基本计算方法</h4>\n<ul>\n<li>\n<p>GCN 基本思想：</p>\n<p>​\t<strong>消息传递 / 聚合</strong>，即<u>平均其自身与邻居特征后传入神经网络</u>（下图橙色结点为例）。</p>\n<p><img src=\"F:%5CTODOIT%5CGNN%5C7.png\" alt=\"7\"></p>\n</li>\n<li>\n<p>网络层数：</p>\n<p>​    GCN 可以做多层，但一般浅做 2、3 层较合适 (6 个人认识全世界理论)，不会很多层</p>\n<p><img src=\"F:%5CTODOIT%5CGNN%5C8.png\" alt=\"8\"></p>\n<p>​                                                 <u>最后得到每个点的特征向量</u></p>\n</li>\n<li>\n<p>图中基本组成：</p>\n<ul>\n<li>\n<p><strong>G</strong>—— 图</p>\n</li>\n<li>\n<p><strong>A</strong>—— 邻接矩阵</p>\n</li>\n<li>\n<p><strong>D</strong>—— 各个结点</p>\n</li>\n<li>\n<p><strong>F</strong>—— 每个结点的特征</p>\n<p><img src=\"F:%5CTODOIT%5CGNN%5C9.png\" alt=\"9\"></p>\n</li>\n</ul>\n</li>\n<li>\n<p>特征计算方法：</p>\n<ul>\n<li><strong>矩阵乘法</strong></li>\n<li><img src=\"F:%5CTODOIT%5CGNN%5C10.png\" alt=\"10\"></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"邻接的矩阵的变换\"><a class=\"markdownIt-Anchor\" href=\"#邻接的矩阵的变换\">#</a> 邻接的矩阵的变换</h4>\n<ul>\n<li>考虑自身（将度矩阵考虑进去）</li>\n<li>左乘对<strong>行</strong>做<u>归一化</u>操作 + 右乘对<strong>列</strong>做<u>归一化</u>操作（归一化：简化计算的操作）</li>\n</ul>\n<p>​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t大致想法（下图）</p>\n<ul>\n<li><img src=\"F:%5CTODOIT%5CGNN%5C11.png\" alt=\"11\"></li>\n</ul>\n<h4 id=\"ugcn基本原理定义u\"><a class=\"markdownIt-Anchor\" href=\"#ugcn基本原理定义u\">#</a> <u>GCN 基本原理 / 定义</u></h4>\n<ul>\n<li>\n<p><img src=\"F:%5CTODOIT%5CGNN%5C12.png\" alt=\"12\"></p>\n<ul>\n<li><strong>ReLU</strong>，全称为：Rectified Linear Unit，是一种人工神经网络中常用的激活函数，通常意义下，其指代数学中的斜坡函数，即 <u>f ( x ) = max ⁡ ( 0 , x )</u><br>\n<img src=\"F:%5CTODOIT%5CGNN%5C13.png\" alt=\"13\"></li>\n</ul>\n</li>\n<li>\n<p>GCN 层数</p>\n<ul>\n<li>在多个图数据集中，都可以发现两三层比较合适，多反而差了。</li>\n<li><img src=\"F:%5CTODOIT%5CGNN%5C14.png\" alt=\"14\"></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"pytorch-geometric工具包安装与配置方法略\"><a class=\"markdownIt-Anchor\" href=\"#pytorch-geometric工具包安装与配置方法略\">#</a> PyTorch Geometric 工具包安装与配置方法（略）</h4>\n<ul>\n<li>\n<p><a href=\"https://www.bilibili.com/video/BV1j8411876K?p=12&amp;vd_source=d1abfb72c73986bf3b64ed4a087cdf09%EF%BC%88\">https://www.bilibili.com/video/BV1j8411876K?p=12&amp;vd_source=d1abfb72c73986bf3b64ed4a087cdf09（</a><u>Pytorch Gepmetric</u>）</p>\n</li>\n<li>\n<p><a href=\"https://blog.csdn.net/pointer_onlysoul/article/details/121354353?utm_medium=distribute.pc_relevant.none-task-blog-2\">https://blog.csdn.net/pointer_onlysoul/article/details/121354353?utm_medium=distribute.pc_relevant.none-task-blog-2</a><sub>default</sub>baidujs_baidulandingword~default-0-121354353-blog-109139329.235<sup>v35</sup>pc_relevant_default_base3&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=1</p>\n<p>（<u>Anaconda+PyTorch 安装（非英伟达显卡 + win10+Python3.8）</u>）</p>\n</li>\n<li>\n<p><a href=\"https://blog.csdn.net/C_chuxin/article/details/82690093\">https://blog.csdn.net/C_chuxin/article/details/82690093</a></p>\n<p>​\t\t\t\t(本<u>地 python 库与新装 Anaconda 库并存</u>)</p>\n</li>\n</ul>\n<h4 id=\"数据集与邻接矩阵格式karateclub空手道俱乐部案例\"><a class=\"markdownIt-Anchor\" href=\"#数据集与邻接矩阵格式karateclub空手道俱乐部案例\">#</a> 数据集与邻接矩阵格式（——KarateClub 空手道俱乐部案例）</h4>\n<ul>\n<li>\n<p>Graph Neural Networks</p>\n<ul>\n<li>\n<p>致力于解决<strong>不规则</strong>数据结构 (图像和文本相对格式都固定，但是社交网络与化学分子等格式肯定不是固定的)。</p>\n</li>\n<li>\n<p>GNN 模型<u>迭代更新</u>主要基于图中每个节点及其<strong>邻居</strong>的信息。</p>\n<p><img src=\"F:%5CTODOIT%5CGNN%5C15.png\" alt=\"15\"></p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>数据集</strong>: <u><strong>Zachary’s karate club network</strong></u></p>\n<ul>\n<li>该图描述了一个空手道俱乐部会员的社交关系，以 34 名会员作为节点，如果两位会员在俱乐部之外仍保持社交关系，则在节点间增加一条边。每人节点具有一个 34 维的特征向量，一共有 78 条边。在收集数据的过程中，管理人员 John A 和教练 Mr.Hi 之间产生了冲突，会员们选择了站队，一半会员跟随 Mr.Hi 成立了新俱乐部，剩下一半会员找了新教练或退出了俱乐部。</li>\n</ul>\n</li>\n<li>\n<p>代码实现：</p>\n<ul>\n<li>\n<p>获取数据集，打印基础数据指标</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> torch_geometric.datasets <span class=\"keyword\">import</span> KarateClub</span><br><span class=\"line\"></span><br><span class=\"line\">dataset = KarateClub()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Dataset: <span class=\"subst\">&#123;dataset&#125;</span>:&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;======================&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Number of graphs: <span class=\"subst\">&#123;<span class=\"built_in\">len</span>(dataset)&#125;</span>&#x27;</span>)  <span class=\"comment\"># 图的数量—1</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Number of features: <span class=\"subst\">&#123;dataset.num_features&#125;</span>&#x27;</span>) <span class=\"comment\"># 特征个数—34</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Number of classes: <span class=\"subst\">&#123;dataset.num_classes&#125;</span>&#x27;</span>)  <span class=\"comment\"># 数据种类—4</span></span><br><span class=\"line\"></span><br><span class=\"line\">Output:</span><br><span class=\"line\">    Dataset: KarateClub():</span><br><span class=\"line\">    ======================</span><br><span class=\"line\">    Number of graphs: <span class=\"number\">1</span></span><br><span class=\"line\">    Number of features: <span class=\"number\">34</span></span><br><span class=\"line\">    Number of classes: <span class=\"number\">4</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>PyTorch Geometric 中的每个图形都由单个 Data 对象表示，该对象包含描述其图形表示的所有信息。我们可以随时打印数据对象，以接收有关其属性及其形状的简短摘要：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">data = dataset[<span class=\"number\">0</span>]  <span class=\"comment\"># Get the first graph object.</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(data)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;=========================================================&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">Output:</span><br><span class=\"line\">    Data(x=[<span class=\"number\">34</span>, <span class=\"number\">34</span>], edge_index=[<span class=\"number\">2</span>, <span class=\"number\">156</span>], y=[<span class=\"number\">34</span>], train_mask=[<span class=\"number\">34</span>])</span><br><span class=\"line\">\t===========================================================</span><br><span class=\"line\">    </span><br><span class=\"line\">    该数据对象具有<span class=\"number\">4</span>个属性：</span><br><span class=\"line\">    （<span class=\"number\">1</span>）edge_index：<span class=\"string\">&quot;2+边的个数&quot;</span>，属性保存有关图连接性的信息，即每个边缘的源节点和目标节点。 </span><br><span class=\"line\">    （<span class=\"number\">2</span>）PyG进一步将节点特征称为x（为<span class=\"number\">34</span>个节点中的每个节点分配了一个<span class=\"number\">34</span>维特征向量），前面表示样本数量，后面表示特征维度。</span><br><span class=\"line\">    （<span class=\"number\">3</span>）节点标签称为y（每个节点被精确地分配为一个类别）。 </span><br><span class=\"line\">    （<span class=\"number\">4</span>）还有一个名为train_mask的附加属性，它描述了我们已经知道其社区归属的节点。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>详细检查 edge_index 的属性</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> IPython.display <span class=\"keyword\">import</span> Javascript  </span><br><span class=\"line\">display(Javascript(<span class=\"string\">&#x27;&#x27;&#x27;google.colab.output.setIframeHeight(0, true, &#123;maxHeight: 300&#125;)&#x27;&#x27;&#x27;</span>))</span><br><span class=\"line\"> </span><br><span class=\"line\">edge_index = data.edge_index</span><br><span class=\"line\"><span class=\"built_in\">print</span>(edge_index.t())</span><br><span class=\"line\"></span><br><span class=\"line\">Output:</span><br><span class=\"line\">    &lt;IPython.core.display.Javascript <span class=\"built_in\">object</span>&gt;</span><br><span class=\"line\">tensor([[ <span class=\"number\">0</span>,  <span class=\"number\">1</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>,  <span class=\"number\">2</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>,  <span class=\"number\">3</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>,  <span class=\"number\">4</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>,  <span class=\"number\">5</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>,  <span class=\"number\">6</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>,  <span class=\"number\">7</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>,  <span class=\"number\">8</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>, <span class=\"number\">10</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>, <span class=\"number\">11</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>, <span class=\"number\">12</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>, <span class=\"number\">13</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>, <span class=\"number\">17</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>, <span class=\"number\">19</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>, <span class=\"number\">21</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>, <span class=\"number\">31</span>],</span><br><span class=\"line\">        ........</span><br><span class=\"line\">        [<span class=\"number\">33</span>,  <span class=\"number\">8</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>,  <span class=\"number\">9</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">13</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">14</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">15</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">18</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">19</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">20</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">22</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">23</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">26</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">27</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">28</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">29</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">30</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">31</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">32</span>]])</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>networkx 可视化展示</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 导入使用的模块包</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> IPython.core.display_functions <span class=\"keyword\">import</span> display</span><br><span class=\"line\"><span class=\"keyword\">from</span> torch_geometric.datasets <span class=\"keyword\">import</span> KarateClub</span><br><span class=\"line\"><span class=\"keyword\">import</span> torch</span><br><span class=\"line\"><span class=\"keyword\">import</span> networkx <span class=\"keyword\">as</span> nx</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">from</span> torch_geometric.utils <span class=\"keyword\">import</span> to_networkx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义最后可视化的函数</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">visualize</span>(<span class=\"params\">h, color, epoch=<span class=\"literal\">None</span>, loss=<span class=\"literal\">None</span></span>):</span><br><span class=\"line\">    plt.figure(figsize=(<span class=\"number\">7</span>, <span class=\"number\">7</span>))</span><br><span class=\"line\">    plt.xticks([])</span><br><span class=\"line\">    plt.yticks([])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> torch.is_tensor(h):</span><br><span class=\"line\">        h = h.detach().cpu().numpy()</span><br><span class=\"line\">        plt.scatter(h[:, <span class=\"number\">0</span>], h[:, <span class=\"number\">1</span>], s=<span class=\"number\">140</span>, c=color, cmap=<span class=\"string\">&quot;Set2&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> epoch <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span> <span class=\"keyword\">and</span> loss <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            plt.xlabel(<span class=\"string\">f&#x27;Epoch: <span class=\"subst\">&#123;epoch&#125;</span>, Loss: <span class=\"subst\">&#123;loss.item():<span class=\"number\">.4</span>f&#125;</span>&#x27;</span>, fontsize=<span class=\"number\">16</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        nx.draw_networkx(G, pos=nx.spring_layout(G, seed=<span class=\"number\">42</span>), with_labels=<span class=\"literal\">False</span>,</span><br><span class=\"line\">                         node_color=color, cmap=<span class=\"string\">&quot;Set2&quot;</span>)</span><br><span class=\"line\">    plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\">G = to_networkx(data, to_undirected=<span class=\"literal\">True</span>)\t<span class=\"comment\">#data上述步骤已给</span></span><br><span class=\"line\">visualize(G, color=data.y)</span><br></pre></td></tr></table></figure>\n<p>​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<u><strong>可视化</strong></u></p>\n</li>\n<li>\n<p><img src=\"F:%5CTODOIT%5CGNN%5C16.png\" alt=\"16\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"模型定义与训练方法\"><a class=\"markdownIt-Anchor\" href=\"#模型定义与训练方法\">#</a> 模型定义与训练方法</h4>\n<ul>\n<li>\n<p>模型定义</p>\n<ul>\n<li>\n<p>三层 GCN</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> torch</span><br><span class=\"line\"><span class=\"keyword\">from</span> torch.nn <span class=\"keyword\">import</span> Linear</span><br><span class=\"line\"><span class=\"keyword\">from</span> torch_geometric.nn <span class=\"keyword\">import</span> GCNConv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">GCN</span>(torch.nn.Module):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(GCN, self).__init__()</span><br><span class=\"line\">        torch.manual_seed(<span class=\"number\">1234</span>)</span><br><span class=\"line\">        self.conv1 = GCNConv(dataset.num_features, <span class=\"number\">4</span>)</span><br><span class=\"line\">        self.conv2 = GCNConv(<span class=\"number\">4</span>, <span class=\"number\">4</span>)\t<span class=\"comment\"># 数字表示维度</span></span><br><span class=\"line\">        self.conv3 = GCNConv(<span class=\"number\">4</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">        self.classifier = Linear(<span class=\"number\">2</span>, dataset.num_classes)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">forward</span>(<span class=\"params\">self, x, edge_index</span>):       <span class=\"comment\"># edge_index 为邻接矩阵</span></span><br><span class=\"line\">        h = self.conv1(x, edge_index)</span><br><span class=\"line\">        h = h.tanh()    <span class=\"comment\"># 双曲正切函数</span></span><br><span class=\"line\">        h = self.conv2(h, edge_index)</span><br><span class=\"line\">        h = h.tanh()</span><br><span class=\"line\">        h = self.conv3(h, edge_index)</span><br><span class=\"line\">        h = h.tanh()  <span class=\"comment\"># Final GNN embedding space.</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># Apply a final (linear) classifier.    全连接</span></span><br><span class=\"line\">        out = self.classifier(h)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> out, h</span><br><span class=\"line\"></span><br><span class=\"line\">model = GCN()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(model)</span><br><span class=\"line\"></span><br><span class=\"line\">Output:</span><br><span class=\"line\">    GCN(</span><br><span class=\"line\">  (conv1): GCNConv(<span class=\"number\">34</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">  (conv2): GCNConv(<span class=\"number\">4</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">  (conv3): GCNConv(<span class=\"number\">4</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">  (classifier): Linear(in_features=<span class=\"number\">2</span>, out_features=<span class=\"number\">4</span>, bias=<span class=\"literal\">True</span>)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p>输出特征展示</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">_, h = model(data.x, data.edge_index)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Embedding shape: <span class=\"subst\">&#123;<span class=\"built_in\">list</span>(h.shape)&#125;</span>&#x27;</span>)</span><br><span class=\"line\">visualize(h, color=data.y)</span><br></pre></td></tr></table></figure>\n<p>​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<u><strong>可视化</strong></u></p>\n<p><img src=\"F:%5CTODOIT%5CGNN%5C17.png\" alt=\"17\"></p>\n</li>\n<li>\n<p><strong>训练模型</strong>（半监督，semi—supervised）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">from</span> IPython.display <span class=\"keyword\">import</span> Javascript  <span class=\"comment\"># Restrict height of output cell.</span></span><br><span class=\"line\"></span><br><span class=\"line\">display(Javascript(<span class=\"string\">&#x27;&#x27;&#x27;google.colab.output.setIframeHeight(0, true, &#123;maxHeight: 430&#125;)&#x27;&#x27;&#x27;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">criterion = torch.nn.CrossEntropyLoss()  <span class=\"comment\"># Define loss criterion.</span></span><br><span class=\"line\">optimizer = torch.optim.Adam(model.parameters(), lr=<span class=\"number\">0.01</span>)  <span class=\"comment\"># Define optimizer.</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">train</span>(<span class=\"params\">data</span>):</span><br><span class=\"line\">    optimizer.zero_grad()  <span class=\"comment\"># Clear gradients.</span></span><br><span class=\"line\">    out, h = model(data.x, data.edge_index)  <span class=\"comment\"># Perform a single forward pass.</span></span><br><span class=\"line\">    loss = criterion(out[data.train_mask],</span><br><span class=\"line\">                     data.y[data.train_mask])  <span class=\"comment\"># Compute the loss solely based on the training nodes.</span></span><br><span class=\"line\">    loss.backward()  <span class=\"comment\"># Derive gradients.</span></span><br><span class=\"line\">    optimizer.step()  <span class=\"comment\"># Update parameters based on gradients.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> loss, h</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> epoch <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">401</span>):</span><br><span class=\"line\">    loss, h = train(data)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> epoch % <span class=\"number\">10</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">        visualize(h, color=data.y, epoch=epoch, loss=loss)</span><br><span class=\"line\">        time.sleep(<span class=\"number\">0.3</span>)</span><br></pre></td></tr></table></figure>\n<p>​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<strong><u>可视化</u></strong></p>\n<p><img src=\"F:%5CTODOIT%5CGNN%5C18.png\" alt=\"18\"></p>\n<p><img src=\"F:%5CTODOIT%5CGNN%5C19.png\" alt=\"19\"></p>\n</li>\n</ul>\n<h4 id=\"\"><a class=\"markdownIt-Anchor\" href=\"#\">#</a> </h4>\n",
            "tags": []
        },
        {
            "id": "http://aer0liteee.github.io/post/e73517db.html",
            "url": "http://aer0liteee.github.io/post/e73517db.html",
            "title": "SQL注入",
            "date_published": "2023-07-02T02:11:52.000Z",
            "content_html": "<h3 id=\"sql注入\"><a class=\"markdownIt-Anchor\" href=\"#sql注入\">#</a> SQL 注入</h3>\n<ul>\n<li>\n<p>概念：</p>\n<ul>\n<li>所谓的 sql 注入就是通过某种方式<strong>将恶意的 sql 代码添加到输入参数</strong>中，然后传递到 sql 服务器使其解析并执行的一种攻击手法。</li>\n</ul>\n</li>\n<li>\n<p>示例：</p>\n<ul>\n<li>\n<p>假设有一个登录表单，应用程序使用提交的用户名和密码来构建 SQL 查询：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$username = $_POST[&#x27;username&#x27;];</span><br><span class=\"line\">$password = $_POST[&#x27;password&#x27;];</span><br><span class=\"line\"></span><br><span class=\"line\">$sql = &quot;SELECT * FROM users WHERE username = &#x27;$username&#x27; AND password = &#x27;$password&#x27;&quot;;</span><br></pre></td></tr></table></figure>\n<p>如果应用程序没有对用户输入进行适当的处理和转义，攻击者可能会在用户名字段中输入恶意代码，例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x27; OR &#x27;1&#x27;=&#x27;1&#x27;--</span><br></pre></td></tr></table></figure>\n<p>在这种情况下，构建的 SQL 查询将变成：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT * FROM users WHERE username = &#x27;&#x27; OR &#x27;1&#x27;=&#x27;1&#x27;--&#x27; AND password = &#x27;$password&#x27;</span><br></pre></td></tr></table></figure>\n<p>这个查询的条件始终成立（‘1’=‘1’），绕过了密码验证，从而使攻击者能够成功登录或绕过应用程序的安全措施。</p>\n<p>为了防止 SQL 注入攻击，应用程序应该始终对用户输入进行验证、过滤和转义。最好的防御措施之一是使用参数化查询或预编译语句，它们可以防止恶意的 SQL 代码注入。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>基本步骤</p>\n<ul>\n<li>\n<p><strong>SQL 注入步骤</strong><br>\n（1）判断是否存在注入，注入是字符型还是数字型</p>\n<blockquote>\n<p>​\t\t首先 id 后面加单引号 查看是否可能存在 sql 注入，返回正常，不存在；返回不正常，存在</p>\n</blockquote>\n<p>（2）猜解 SQL 查询语句中的字段数<br>\n（3）判断哪些位置字段可以注入利用<br>\n（4）查询数据库（当前使用数据库或所有数据库）<br>\n（5）查询指定数据库中的表<br>\n（6）查询指定表中的字段名<br>\n（7）查询表中字段的值</p>\n</li>\n</ul>\n</li>\n<li>\n<p>常见方式：</p>\n<ul>\n<li>\n<p>可以将 SQL 注入分为两大类：<br>\n<strong>非盲注</strong>和<strong>盲注</strong>，<u>非盲注就是有报错回显</u>，<u>盲注就是没有报错回显</u></p>\n</li>\n<li>\n<p>常见的 SQL 注入方法有：</p>\n<ul>\n<li>\n<p><strong>联合注入</strong></p>\n<ul>\n<li>\n<p>原理<br>\n（1）<strong>union select</strong> 定义<br>\n将多个 SELECT 语句的结果合并到一个结果集中<br>\n（2）mysql 直观测试</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"code\"><pre><span class=\"line\">复制代码<span class=\"keyword\">SELECT</span> <span class=\"operator\">*</span> <span class=\"keyword\">FROM</span> users <span class=\"keyword\">WHERE</span> id<span class=\"operator\">=</span><span class=\"string\">&#x27;1&#x27;</span> <span class=\"keyword\">union</span> <span class=\"keyword\">select</span> <span class=\"operator\">*</span> <span class=\"keyword\">from</span> users <span class=\"keyword\">where</span> id<span class=\"operator\">=</span><span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>相关函数</p>\n<ul>\n<li>group_concat (参数 1，参数 2，参数 3 等等无数个参数) 语法： <strong>group_concat</strong> 函数<u>返回一个字符串结果</u>(就是返回一行)，该结果由括号中的各个参数值执行然后连接组合而成</li>\n<li>char ()：还原 ASCII 码为字符</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>布尔盲注</strong></p>\n<ul>\n<li>\n<p>原理<br>\n Web 的页面的<u>仅仅会返回 True 和 False</u>，那么布尔盲注就是根据页面返回的 True 或者是 False 来得到数据库中的相关信息</p>\n</li>\n<li>\n<p>相关函数解析</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">length：返回值为字符串的字节长度</span><br><span class=\"line\">ascii：把字符转换成ascii码值的函数</span><br><span class=\"line\">substr(str, pos, len)：在str中从pos开始的位置（起始位置为1），截取len个字符</span><br><span class=\"line\">count：统计表中记录的一个函数，返回匹配条件的行数</span><br><span class=\"line\">limit：</span><br><span class=\"line\">     limit m ：检索前m行数据，显示1-10行数据（m&gt;0）</span><br><span class=\"line\">     limit(x,y)：检索从x+1行开始的y行数据</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>时间盲注</strong></p>\n<ul>\n<li>\n<p>原理：</p>\n<ul>\n<li>时间盲注的一般思路是延迟注入，就是利用<strong> sleep ()<strong> 或</strong> benchmark ()<strong> 等函数让 mysql 执行时间变长并结合判断条件语句 if (expr1,expr2,expr3)，然后</strong>通过页面的响应时间长短</strong>来判断语句返回的值是 True 还是 False，从而猜解一些未知的字段</li>\n</ul>\n</li>\n<li>\n<p>相关函数：</p>\n<ul>\n<li>if (expr1,expr2,expr3)： expr1 的值为 TRUE，则返回值为 expr2 ；expr1 的值为 FALSE，则返回值为 expr3<br>\nsleep (n)：延迟响应时间 n 秒</li>\n</ul>\n</li>\n<li>\n<p>示例：</p>\n<ul>\n<li>\n<p>假设有一个搜索功能，用户可以在网站上搜索电影标题。搜索功能的查询语句通过将用户提供的搜索关键字嵌入到 SQL 查询中来生成结果。例如，查询语句如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT * FROM movies WHERE title LIKE &#x27;%用户输入的关键字%&#x27;</span><br></pre></td></tr></table></figure>\n<p>这个查询语句会返回包含用户搜索关键字的电影标题。</p>\n<p>攻击者可以利用时间盲注来判断特定条件是否满足，例如是否存在一个特定的电影。</p>\n<p>假设攻击者要判断电影名称为 “The Matrix” 是否存在。攻击者可以通过向搜索字段输入恶意的搜索字符串来触发时间延迟，如果延迟时间较长，则可以推断条件为真，否则推断为假。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">搜索关键字：&#x27; OR IF(SUBSTRING((SELECT title FROM movies WHERE title = &#x27;The Matrix&#x27;),1,1)=&#x27;T&#x27;, SLEEP(5), 0) AND &#x27;1%&#x27;=&#x27;1</span><br></pre></td></tr></table></figure>\n<p>在上述示例中，攻击者通过构造恶意的搜索字符串进行注入。该字符串使用  <code>IF</code>  函数和  <code>SLEEP</code>  函数来引起延迟，在查询执行期间等待 5 秒钟。如果条件  <code>SUBSTRING((SELECT title FROM movies WHERE title = 'The Matrix'),1,1)='T'</code>  为真，即判断电影名称的第一个字符是 ‘T’，则会发生延迟。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>宽字节注入</strong></p>\n<ul>\n<li>\n<p>原理：</p>\n<ul>\n<li>当存在宽字节注入的时候，注入参数里带入％df％27，即可把（％5c）吃掉，也就是 % df 和 %5c 结合成了汉字運</li>\n</ul>\n</li>\n<li>\n<p>示例：</p>\n<ul>\n<li></li>\n</ul>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$userid = $_GET[&#x27;id&#x27;];</span><br><span class=\"line\">$query = &quot;SELECT * FROM users WHERE id = &#x27;$userid&#x27;&quot;;</span><br></pre></td></tr></table></figure>\n<p>在正常情况下，如果用户提供的  <code>id</code>  参数是单字节编码，应用程序会将其包含在查询字符串中。然而，通过在  <code>id</code>  参数中使用宽字节编码，攻击者可以绕过过滤机制，将恶意注入的 SQL 代码作为有效数据执行。例如，假设攻击者提供的  <code>id</code>  参数是  <code>%bf' OR '1'='1</code> ，其中  <code>%bf</code>  是宽字节编码的  <code>'</code>  。</p>\n<p>在这种情况下，构建的 SQL 查询变成了：</p>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT * FROM users WHERE id = &#x27;�&#x27; OR &#x27;1&#x27;=&#x27;1&#x27;</span><br></pre></td></tr></table></figure>\n<p>这将导致查询条件始终为真（‘1’=‘1’），从而绕过了应用程序的身份验证，可能导致数据泄露、修改或其他安全问题。</p>\n<p>为了防止宽字节注入攻击，应用程序应该正确处理和验证输入的数据，特别是字符编码方面。建议采用参数化查询或使用安全的编码和解码机制，以避免受到这种类型的注入攻击。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>报错注入</strong></p>\n<ul>\n<li>\n<p>原理：</p>\n<ul>\n<li>报错注入是通过特殊函数错误使用并使其输出错误结果来获取信息的。</li>\n</ul>\n</li>\n<li>\n<p>相关函数：</p>\n<figure class=\"highlight scss\"><table><tr><td class=\"code\"><pre><span class=\"line\">·<span class=\"built_in\">concat</span>()函数：用于将多个字符串连接成一个字符串</span><br><span class=\"line\">·<span class=\"built_in\">floor</span>(x) 函数：返回小于 x 的最大整数值</span><br><span class=\"line\">·<span class=\"built_in\">rand</span>()函数调：用可以在<span class=\"number\">0</span>和<span class=\"number\">1</span>之间产生一个随机数</span><br><span class=\"line\">·group by语句：根据一个或多个列对结果集进行分组</span><br><span class=\"line\">·<span class=\"built_in\">updatexml</span>(目标xml文档，xml路径，更新的内容)：更新xml文档的函数，xpath_expr： 需要更新的xml路径(Xpath格式)</span><br><span class=\"line\">·new_xml： 更新后的内容</span><br><span class=\"line\">此函数用来更新选定XML片段的内容，将XML标记的给定片段的单个部分替换为 xml_target 新的XML片段 new_xml ，然后返回更改的XML。xml_target替换的部分 与xpath_expr 用户提供的XPath表达式匹配。</span><br><span class=\"line\"><span class=\"built_in\">extractvalue</span>(目标xml文档，xml路径)：对XML文档进行查询的函数，一个XML标记片段 xml_frag和一个XPath表达式 xpath_expr（也称</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>示例：</p>\n<ul>\n<li>\n<p>假设有一个登录页面，您需要输入用户名和密码进行身份验证。该应用程序使用以下查询语句进行验证：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT * FROM users WHERE username = &#x27;输入的用户名&#x27; AND password = &#x27;输入的密码&#x27;</span><br></pre></td></tr></table></figure>\n<p>攻击者可以使用报错注入来利用应用程序中的错误消息来获取敏感信息，例如数据库的名称、表的名称等。</p>\n<p>以下是一个示例的报错注入攻击：</p>\n<p>假设攻击者要尝试通过报错注入来获取数据库的名称。攻击者在用户名字段中输入以下内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#x27; OR 1=1 ORDER BY 1--</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，攻击者向用户名字段中注入了恶意代码，即  <code>' OR 1=1 ORDER BY 1--</code> 。这段代码仅仅是为了触发报错，而不是以正常的方式进行身份验证。</p>\n<p>当应用程序执行查询时，由于注入的代码的存在，查询将变成以下形式：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT * FROM users WHERE username = &#x27;&#x27; OR 1=1 ORDER BY 1--&#x27; AND password = &#x27;输入的密码&#x27;</span><br></pre></td></tr></table></figure>\n<p>上述查询中的  <code>ORDER BY 1</code>  是一种常见的错误引起的操作。如果查询执行成功，将不会发生错误，但如果查询失败，应用程序通常会显示错误消息或异常信息。</p>\n<p>通过观察错误消息或异常信息，攻击者可以推断出数据库的名称，例如：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">Error: Unknown column &#x27;1&#x27; in &#x27;order clause&#x27;</span><br></pre></td></tr></table></figure>\n<p>从错误消息中，攻击者可以推断出数据库中存在一个名为  <code>1</code>  的列，这暗示了数据库中的一些结构信息。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>堆叠注入</strong></p>\n<ul>\n<li>\n<p>原理</p>\n<ul>\n<li>堆叠注入与受限于 select 语句的联合查询法相反，堆叠注入可用于执行任意 SQL 语句，<u>简单地说就是 MYSQL 的多语句查询</u></li>\n<li>堆叠注入的局限性：堆叠注入并不是在任何换环境下都可以执行的，可能受到 API 或者数据库引擎不支持的限制（如 Oracle 数据库），也有可能权限不足。web 系统中，因为代码通常只返回一个查询结果，因此堆叠注入第二个语句产生错误或者结果只能被忽略，我们在前端界面是无法看到返回结果的。</li>\n</ul>\n</li>\n<li>\n<p>示例：</p>\n<ul>\n<li>\n<p>假设我们有一个简单的登录表单，用于验证用户的用户名和密码。应用程序使用传递的用户名和密码构建 SQL 查询：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">$username = $_POST[&#x27;username&#x27;];</span><br><span class=\"line\">$password = $_POST[&#x27;password&#x27;];</span><br><span class=\"line\"></span><br><span class=\"line\">$sql = &quot;SELECT * FROM users WHERE username = &#x27;$username&#x27; AND password = &#x27;$password&#x27;&quot;;</span><br></pre></td></tr></table></figure>\n<p>在这个例子中，应用程序没有正确地验证和过滤用户输入，存在 SQL 注入漏洞。</p>\n<p>下面是堆叠注入的示例攻击：</p>\n<p>假设攻击者在用户名字段中输入了以下内容：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">admin&#x27; OR 1=1; --</span><br></pre></td></tr></table></figure>\n<p>在这种情况下，构建的 SQL 查询将变成：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">SELECT * FROM users WHERE username = &#x27;admin&#x27; OR 1=1; --&#x27; AND password = &#x27;$password&#x27;</span><br></pre></td></tr></table></figure>\n<p>这个查询中的  <code>OR 1=1; --</code>  部分是攻击者注入的恶意代码。它将使查询条件始终为真，因为  <code>1=1</code>  恒为真。 <code>--</code>  是 SQL 的注释标记，用于注释掉原始查询中的剩余部分。结果是，攻击者可以成功绕过身份验证，登录到系统中，即使他们提供了错误的密码。</p>\n<p><strong>堆叠注入的关键是在注入点中添加分号  <code>;</code>  来结束原始查询，然后添加额外的 SQL 语句来实现攻击者想要的恶意行为。这种技术可用于执行任意的 SQL 语句，如插入、更新或删除数据，甚至执行系统命令等。</strong></p>\n<p>要防止堆叠注入攻击，应用程序应该对所有用户输入进行正确的验证和转义，或者更好地使用参数化查询或预编译语句。这样可以防止注入的 SQL 代码被认为是有效的查询语句的一部分。确保在编写应用程序时实施严格的输入验证和过滤机制是至关重要的，以减少安全漏洞的出现</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>二次注入</strong></p>\n<ul>\n<li>\n<p>原理</p>\n<ul>\n<li>\n<p>二次注入可以理解为，攻击者构造的恶意数据存储在数据库后，恶意数据被读取并进入到 SQL 查询语句所导致的注入。防御者可能在用户输入恶意数据时对其中的特殊字符进行了转义处理，但在恶意数据插入到数据库时被处理的数据又被还原并存储在数据库中（比如虽然参数在过滤后会添加 &quot;“进行转义，但是”&quot; 并不会插入到数据库中），当<u>Web 程序调用存储在数据库中的恶意数据并执行 SQL 查询时，就发生了 SQL 二次注入</u>。</p>\n<p><img src=\"https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/fe7f5e853e9b4717949e71a1d10c229b~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp\" alt=\"在这里插入图片描述\"></p>\n<p>二次注入，可以概括为以下两步：</p>\n</li>\n<li>\n<p>第一步：插入恶意数据</p>\n<ul>\n<li>进行数据库插入数据时，对其中的特殊字符进行了转义处理，在写入数据库的时候又保留了原来的数据。</li>\n</ul>\n</li>\n<li>\n<p>第二步：引用恶意数据</p>\n<ul>\n<li>开发者默认存入数据库的数据都是安全的，在进行查询时，直接从数据库中取出恶意数据，没有进行进一步的检验的处理。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>示例：</p>\n<ul>\n<li>\n<p>用户 A 在评论中输入以下内容：  <code>Nice post! Please check out my website at www.example.com'; DELETE FROM comments; --</code></p>\n<p>应用程序将评论内容存储在数据库中，但并不立即执行。当其他用户访问留言板页面时，应用程序从数据库中获取评论并将其显示在页面上。在获取评论的过程中，存在不当的代码执行，导致用户 A 注入的恶意代码被执行。</p>\n</li>\n<li>\n<p>在这个示例中，用户 A 在评论中注入了一个恶意代码，即  <code>'; DELETE FROM comments; --</code> 。这段代码旨在删除数据库中的评论表中的所有内容。由于应用程序在处理评论时存在漏洞，并没有正确地过滤或转义用户输入，导致注入的恶意代码被存储在数据库中。当其他用户访问留言板页面时，应用程序从数据库中检索评论并显示在页面上，但由于存在不当的代码执行，导致用户 A 注入的恶意代码被执行，从而删除了评论表中的所有内容。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>SQLMap 使用</p>\n<ul>\n<li>\n<p>常见参数：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">diff复制代码-u：指定含有参数的URL</span><br><span class=\"line\">--dbs：爆出数据库</span><br><span class=\"line\">--batch：默认选择执行</span><br><span class=\"line\">--random-agent：使用随机user-agent</span><br><span class=\"line\">-r：POST注入</span><br><span class=\"line\">--level：注入等级，一共有5个等级（1-5） 不加 level 时，默认是1，5级包含的payload最多，会自动破解出cookie、XFF等头部注入，相对应他的速度也比较慢</span><br><span class=\"line\">--timeout：设定重试超时</span><br><span class=\"line\">--cookie：设置cookie信息</span><br><span class=\"line\">--flush-session：删除指定目标缓存，重新对该目标进行测试</span><br><span class=\"line\">--tamper：使用waf绕过脚本</span><br><span class=\"line\">--time-sec：设定延时时间，默认是5秒</span><br><span class=\"line\">--thread：多线程，默认为1，最大为10</span><br><span class=\"line\">--keep-live： sqlmap默认是一次连接成功后马上关闭；HTTP报文中相当于Connection: Close（一次连接马上关闭）。要扫描站点的URL</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><strong>对 url 进行检测，判断是否存在 SQL 注入</strong></p>\n<ul>\n<li>python <a href=\"http://sqlmap.py\">sqlmap.py</a> -u “url” --batch</li>\n</ul>\n</li>\n<li>\n<p><strong>获取数据库</strong></p>\n<ul>\n<li>python <a href=\"http://sqlmap.py\">sqlmap.py</a> -u URL --dbs --batch 获取全部数据库</li>\n<li>python <a href=\"http://sqlmap.py\">sqlmap.py</a> -u URL --current-db --batch 获取当前数据库</li>\n</ul>\n</li>\n<li>\n<p><a href=\"http://sqlmap.py\">sqlmap.py</a> -u “<a href=\"http://url/news?id=1\">http://url/news?id=1</a>”  --dump -C “column_name” -T “table_name” -D “db_name”</p>\n</li>\n<li>\n<p><strong>POST 注入</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sqlmap -u “http://url/news/” --data=&quot;id=2” --cookie=&quot;&quot; //加cookie</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p><strong>使用 sqlmap 自带的过 waf 脚本：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">sqlmap.py -u “http://test.com/test.php?Id=1” --tamper[“脚本名称”]（如果脚本失效，可以自定义脚本）</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n",
            "tags": [
                "Web"
            ]
        },
        {
            "id": "http://aer0liteee.github.io/post/4a17b156.html",
            "url": "http://aer0liteee.github.io/post/4a17b156.html",
            "title": "Hello World",
            "date_published": "2023-07-01T01:43:38.368Z",
            "content_html": "<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"quick-start\"><a class=\"markdownIt-Anchor\" href=\"#quick-start\">#</a> Quick Start</h2>\n<h3 id=\"create-a-new-post\"><a class=\"markdownIt-Anchor\" href=\"#create-a-new-post\">#</a> Create a new post</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"run-server\"><a class=\"markdownIt-Anchor\" href=\"#run-server\">#</a> Run server</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"generate-static-files\"><a class=\"markdownIt-Anchor\" href=\"#generate-static-files\">#</a> Generate static files</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"deploy-to-remote-sites\"><a class=\"markdownIt-Anchor\" href=\"#deploy-to-remote-sites\">#</a> Deploy to remote sites</h3>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n",
            "tags": []
        }
    ]
}