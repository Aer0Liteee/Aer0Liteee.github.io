{
    "version": "https://jsonfeed.org/version/1",
    "title": "GWXX • All posts by \"deep-learning\" category",
    "description": "",
    "home_page_url": "http://Aer0Liteee.github.io",
    "items": [
        {
            "id": "http://aer0liteee.github.io/post/bdbefb72.html",
            "url": "http://aer0liteee.github.io/post/bdbefb72.html",
            "title": "MML",
            "date_published": "2023-07-16T14:44:07.000Z",
            "content_html": "<h1 id=\"多模态学习multimodal-learning\"><a class=\"markdownIt-Anchor\" href=\"#多模态学习multimodal-learning\">#</a> 多模态学习 (MultiModal Learning)</h1>\n<h2 id=\"定义\"><a class=\"markdownIt-Anchor\" href=\"#定义\">#</a> 定义</h2>\n<p><strong><u>多模态机器学习</u></strong>，英文全称 MultiModal Machine Learning (MMML)</p>\n<h3 id=\"模态\"><a class=\"markdownIt-Anchor\" href=\"#模态\">#</a> 模态</h3>\n<p>​\t\t<strong>模态</strong>，是指一些表达或感知事物的方式，每一种<u>信息的来源或者形式</u>，都可以称为一种模态。例如，人有触觉，听觉，视觉，嗅觉；信息的媒介，有语音、视频、文字等；多种多样的传感器，如雷达、红外、加速度计等，以上的每一种都可以称为一种模态。</p>\n<p><img src=\"https://oss.imzhanghao.com/img/202211051318189.png\" alt=\"What is Mulimodel\"></p>\n<p>​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  \t<strong><u>感知模态</u></strong></p>\n<ul>\n<li>​\t\t我们生活在一个由多种模态（Multimodal）信息构成的世界，包括<strong>视觉信息、听觉信息、文本信息、嗅觉信息</strong>等等，当研究的问题或者数据集包含多种这样的模态信息时我们称之为多模态问题，研究多模态问题是推动人工智能更好的了解和认知我们周围世界的关键。</li>\n</ul>\n<blockquote>\n<p>相较于图像、语音、文本等多媒体 (Multi-media) 数据划分形式，“模态” 是一个更为细粒度的概念，<strong>同一媒介下可存在不同的模态</strong>。</p>\n<p>比如我们可以把<u>两种不同的语言当做是两种模态</u>，甚至在<u>两种不同情况下采集到的数据集</u>，亦可认为是两种模态。</p>\n</blockquote>\n<h3 id=\"多模态\"><a class=\"markdownIt-Anchor\" href=\"#多模态\">#</a> 多模态</h3>\n<p>​\t\t<strong>多模态</strong>，即是从多个模态表达或感知事物。 多模态可归类为<u>同质性的模态</u>，例如从两台相机中分别拍摄的图片；<u>异质性的模态</u>，例如图片与文本语言的关系。</p>\n<p>​\t<strong>多模态可能有以下三种形式：</strong></p>\n<ul>\n<li>\n<p><strong>来自不同传感器的同一类媒体数据</strong>。如物联网背景下<u>不同传感器所检测到的同一对象数据</u>等。</p>\n</li>\n<li>\n<p><strong>具有不同的数据结构特点、表示形式的表意符号与信息</strong>。如描述同一对象的结构化、非结构化的数据单元；描述<u>同一数学概念的公式、逻辑符号、函数图及解释性文本</u>等。</p>\n</li>\n<li>\n<p><strong>描述同一对象的多媒体数据</strong>。如互联网环境下描述某一特定对象的<u>视频、图片、语音、文本</u>等信息。</p>\n<p>​\t\t\t\t\t\t\t\t\t\t\t下图即为典型的多模态信息形式</p>\n<p><img src=\"https://oss.imzhanghao.com/img/202211050816652.png\" alt=\"“下雪”场景的多模态数据(图像、音频与文本)\"></p>\n<p>通常主要研究模态包括 &quot;<strong>3V</strong>&quot;：即<strong> Verbal (文本)、Vocal (语音)、Visual (视觉)</strong>。</p>\n<p>​\t人跟人交流时的多模态：</p>\n<ul>\n<li>视觉\n<ul>\n<li>手势：头、眼、手</li>\n<li>肢体语言：体态、空间距离关系</li>\n<li>眼神交流：头、眼</li>\n<li>面部表情：笑容、皱眉……</li>\n</ul>\n</li>\n<li>语言\n<ul>\n<li>韵律：语调、语音质量</li>\n<li>声音：哭、笑……</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"https://oss.imzhanghao.com/img/202211051318784.png\" alt=\"multimodal communicative behaviors\"></p>\n<h3 id=\"多模态机器学习\"><a class=\"markdownIt-Anchor\" href=\"#多模态机器学习\">#</a> 多模态机器学习</h3>\n<p>​\t<strong>多模态机器学习</strong>是从多种模态的数据中学习并且提升自身的算法，它不是某一个具体的算法，它是一类算法的总称。</p>\n<p>从<strong>语义感知</strong>的角度切入，多模态数据涉及<strong>不同的感知通道</strong>如视觉、听觉、触觉、嗅觉所接收到的信息；在<strong>数据层面</strong>理解，多模态数据则可被看作<strong>多种数据类型</strong>的组合，如图片、数值、文本、符号、音频、时间序列，或者集合、树、图等不同数据结构所组成的复合数据形式，乃至来自不同数据库、不同知识库的各种信息资源的组合。<strong>对多源异构数据的挖掘分析可被理解为多模态学习</strong>。</p>\n<p><img src=\"https://oss.imzhanghao.com/img/202211051125254.png\" alt=\"多模态学习举例\"></p>\n<p>​\t   将同个对象（同一种数据）的不同输出形式进行多模态学习融合后进行预测</p>\n</li>\n</ul>\n<h2 id=\"发展历史\"><a class=\"markdownIt-Anchor\" href=\"#发展历史\">#</a> 发展历史</h2>\n<p><img src=\"https://oss.imzhanghao.com/img/202211051008371.png\" alt=\"多模态发展的四个时期\"></p>\n<h3 id=\"行为时代\"><a class=\"markdownIt-Anchor\" href=\"#行为时代\">#</a> 行为时代</h3>\n<p>从心理学的角度对多模态这一现象进行剖析。</p>\n<h3 id=\"计算时代\"><a class=\"markdownIt-Anchor\" href=\"#计算时代\">#</a> 计算时代</h3>\n<p>利用一些浅层的模型对多模态问题进行研究，其中代表性的应用包括视觉语音联合识别，多模态情感计算等等。</p>\n<h3 id=\"交互时代\"><a class=\"markdownIt-Anchor\" href=\"#交互时代\">#</a> 交互时代</h3>\n<p>从交互的角度入手，研究多模态识别问题，拟人类多模态交互过程，其中主要的代表作品包括苹果的语音助手 Siri、IDIAP 实验室（瑞士人工智能研究机构）的 AMI 项目（记录会议录音、同步音频视频、转录与注释）等。</p>\n<h3 id=\"深度学习时代\"><a class=\"markdownIt-Anchor\" href=\"#深度学习时代\">#</a> 深度学习时代</h3>\n<p>多模态研究发展迅猛，得益于新的大规模多模态数据集、GPU 快速计算、强大的视觉特征抽取能力、强大的语言特征抽取能力。</p>\n<p><img src=\"https://oss.imzhanghao.com/img/202211050837453.png\" alt=\"多模态机器学习在Google Trends上的表现\"></p>\n<h2 id=\"典型任务\"><a class=\"markdownIt-Anchor\" href=\"#典型任务\">#</a> 典型任务</h2>\n<h3 id=\"language-audio\"><a class=\"markdownIt-Anchor\" href=\"#language-audio\">#</a> Language-Audio</h3>\n<ul>\n<li>Text-to-Speech Synthesis: 给定文本，生成一段对应的声音。</li>\n<li>Audio Captioning：给定一段语音，生成一句话总结并描述主要内容。(不是语音识别)</li>\n</ul>\n<h3 id=\"vision-audio\"><a class=\"markdownIt-Anchor\" href=\"#vision-audio\">#</a> Vision-Audio</h3>\n<ul>\n<li>\n<p>Speech-conditioned Face generation：给定一段话，生成说话人的视频。</p>\n</li>\n<li>\n<p>Audio-Driven 3D Facial Animation：<u>给定一段话与 3D 人脸模版，生成说话的人脸 3D 动画。</u></p>\n<ul>\n<li>\n<p>​\t\t\t\tApple Vision Pro 头显 + Otter AI 助手：打造全新空间计算体验</p>\n<p><img src=\"https://www.apple.com/v/apple-vision-pro/a/images/overview/hero/portrait_base__bwsgtdddcl7m_large.jpg\" alt=\"Person wearing Vision Pro, with eyes visible through front glass\"></p>\n<p>​\t苹果在 2023 年的全球开发者大会上发布了一款令人惊艳的产品：Vision Pro。</p>\n<p>​\t\t\t超高清的显示屏、先进的空间音频系统、无需手柄的手眼语音交互。</p>\n<p>Otter 是一个基于深度学习的多模态 AI 助手，它可以通过 Vision Pro 头显的摄像头捕捉用户的视觉输入，分析用户的环境、情境和意图，生成相应的反馈和指导。Otter 可以理解用户的语言、手势和眼神，与用户进行自然和流畅的对话，帮助用户完成各种任务和活动。</p>\n<p><img src=\"E:%5C%E6%A1%8C%E9%9D%A2%5CGZ%5C%E5%A4%A7%E4%BA%8C%E4%B8%8B%5C8e6b2a5ce8574900a91d6693d9e5ccc5.gif\" alt=\"img\"></p>\n<p>捕获用户视觉、语音输入特征，根据已采集的人脸面部信息生成说话的人脸 3D 动画</p>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"vision-language\"><a class=\"markdownIt-Anchor\" href=\"#vision-language\">#</a> Vision-Language</h3>\n<ul>\n<li>Image/Video Captioning (图像 / 视频描述)：给定一个图像 / 视频，生成文本描述其主要内容。</li>\n<li>Vision-and-Language Navigation (视觉 - 语言导航)： 给定自然语言进行指导，使得智能体根据视觉传感器导航到特定的目标。</li>\n</ul>\n<h3 id=\"定位相关任务\"><a class=\"markdownIt-Anchor\" href=\"#定位相关任务\">#</a> 定位相关任务</h3>\n<ul>\n<li>Object Tracking from Natural Language Query: 给定一段视频和一些文本，追踪视频中文本所描述的对象。</li>\n</ul>\n<h3 id=\"更多模态\"><a class=\"markdownIt-Anchor\" href=\"#更多模态\">#</a> 更多模态</h3>\n<ul>\n<li>Affect Computing (情感计算)：使用语音、视觉 (人脸表情)、文本信息、心电、脑电等模态进行情感识别。</li>\n</ul>\n<h2 id=\"核心技术挑战\"><a class=\"markdownIt-Anchor\" href=\"#核心技术挑战\">#</a> 核心技术挑战</h2>\n<p>​                                                 <u>表征</u> <u>翻译</u> <u>对齐</u> <u>融合</u> <u>协同学习</u></p>\n<p><img src=\"https://oss.imzhanghao.com/img/202211051339734.png\" alt=\"多模态学习的技术挑战\"></p>\n<h3 id=\"表征representation\"><a class=\"markdownIt-Anchor\" href=\"#表征representation\">#</a> 表征 Representation</h3>\n<p>​\t第一个基本挑战是学习如何<strong>利用多种模态的互补性和冗余性的方式表示和总结多模态数据</strong>（<u>个人理解，即如何表示数据让计算机看得懂、能处理</u>）。多模态数据的异质性使得构建这样的表示具有挑战性，例如，语言通常是象征性的，而音频和视觉形式将被表示为信号。</p>\n<blockquote>\n<p>​\t<strong>单模态的表征负责将信息表示为计算机可以处理的数值向量或者进一步抽象为更高层的特征向量。</strong></p>\n<p>​\t<strong>多模态表征是指通过利用多模态之间的互补性，剔除模态间的冗余性，从而学习到更好的特征表示。</strong></p>\n</blockquote>\n<p><img src=\"https://oss.imzhanghao.com/img/202211051431550.png\" alt=\"Representation\"></p>\n<h4 id=\"联合表征\"><a class=\"markdownIt-Anchor\" href=\"#联合表征\">#</a> 联合表征</h4>\n<p>​\t<strong>联合表征</strong>（Joint Representation）<u>将多个模态的信息一起映射到一个统一的多模态向量空间</u>，Joint 结构注重捕捉多模态的<strong>互补性</strong>，融合多个输入模态 x1 , x2 获得多模态表征 Xm = f (x1 ,…,xn)，进而利用 Xm 完成某种预测任务。</p>\n<p><img src=\"https://oss.imzhanghao.com/img/202211052136742.png\" alt=\"Joint Representation\"></p>\n<p>​\tMultimodal learning with deep boltzmann machines (NIPS 2012) 提出将 deep boltzmann machines（DBM） 结构扩充到多模态领域，通过 Multimodal DBM，可以学习到多模态的<strong>联合概率分布</strong>。</p>\n<p><img src=\"https://oss.imzhanghao.com/img/202211051458819.png\" alt=\"Multimodal DBM 模型\"></p>\n<p>​\t在获得图像与文本间的<strong>联合概率分布</strong>后，在应用阶段：</p>\n<ul>\n<li>输入图片，<u>利用条件概率 P (文本 | 图片)，生成文本特征</u>，可以得到图片相应的文本描述；</li>\n<li>输入文本，<u>利用条件概率 P (图片 | 文本)，可以生成图片特征</u>，通过检索出最靠近该特征向量的两个图片实例，可以得到符合文本描述的图片。</li>\n</ul>\n<p><img src=\"https://oss.imzhanghao.com/img/202211051506598.png\" alt=\"Multimodal DBM 应用\"></p>\n<h4 id=\"协同表征\"><a class=\"markdownIt-Anchor\" href=\"#协同表征\">#</a> 协同表征</h4>\n<p>​\t协同表征（Coordinated Representation）<u>将多模态中的每个模态分别映射到各自的表示空间，但映射后的向量之间满足一定的相关性约束（例如线性相关）</u>。Coordinated 结构并不寻求融合而是建模多种模态数据间的<strong>相关性</strong>，它将多个 (通常是两个) 模态映射到协作空间，表示为：f (x1)～g (x2)，其中 **<u>～</u>** 表示一种协作关系。网络的优化目标是这种协作关系 (通常是相似性，即最小化 cosine 距离等度量)。</p>\n<p><img src=\"https://oss.imzhanghao.com/img/202211052203950.png\" alt=\"Coordinated Representation\"></p>\n<p>​\t<u>NIPS 2014</u>（一个关于机器学习和计算神经科学领域的人工智能国际会议) ，利用<strong>协同学习到的特征向量之间满足加减算数运算</strong>这一特性，可以搜索出与给定图片满足 “<strong>指定的转换语义</strong>” 的图片。例如：狗的图片特征向量 - 狗的文本特征向量 + 猫的文本特征向量 = 猫的图片特征向量 -&gt; 在特征向量空间，根据最近邻距离，检索得到猫的图片。</p>\n<p><img src=\"https://oss.imzhanghao.com/img/202211090619157.png\" alt=\"多模态向量空间运算\"></p>\n<h3 id=\"翻译translation\"><a class=\"markdownIt-Anchor\" href=\"#翻译translation\">#</a> 翻译 Translation</h3>\n<p>​\t第二个挑战涉及<strong>如何将数据从一种模式转化（映射）到另一种模式</strong>。不仅数据是异构的，而且模态之间的关系通常是开放式的或主观的。例如，存在多种描述图像的正确方法，并且可能不存在一种完美的翻译。</p>\n<p>​\t\t\t\t\t\t\t\t\t\t\t\t<u>基于实例的方法</u> <u>模型驱动的方法</u></p>\n<p><img src=\"https://oss.imzhanghao.com/img/202211051434189.png\" alt=\"Translation\"></p>\n<h4 id=\"常见应用\"><a class=\"markdownIt-Anchor\" href=\"#常见应用\">#</a> 常见应用</h4>\n<ul>\n<li><strong>机器翻译（Machine Translation）</strong>：将输入的语言 A（即时）翻译为另一种语言 B。类似的还有唇读（Lip Reading）和语音翻译 （Speech Translation），分别将唇部视觉和语音信息转换为文本信息。</li>\n<li><strong>图片描述（Image captioning) 或者视频描述（Video captioning)</strong>： 对给定的图片 / 视频形成一段文字描述，以表达图片 / 视频的内容。</li>\n<li><strong>语音合成（Speech Synthesis）</strong>：根据输入的文本信息，自动合成一段语音信号。</li>\n</ul>\n<h4 id=\"翻译的评估困境\"><a class=\"markdownIt-Anchor\" href=\"#翻译的评估困境\">#</a> 翻译的评估困境</h4>\n<p>​\t多模态翻译方法面临的一个主要挑战是它们很难评估（<u>即在无对错之分的情况下判断哪个是更好的</u>）。语音识别等任务只有一个正确的翻译，而语音合成和媒体描述等任务则没有。有时，就像在语言翻译中，多重答案是正确的，决定哪个翻译更好往往是主观的。</p>\n<ul>\n<li><strong>人工评价</strong>是最理想的评估，但是<u>耗时耗钱</u>，且需要多样化打分人群的背景以避免偏见。</li>\n<li><strong>自动化指标</strong>是视觉描述领域常用的替代方法，包括 BLEU，Meteor，CIDEr，ROUGE 等，但它们被证实与人的评价相关性较弱。</li>\n<li><strong>基于检索的评估</strong>和<strong>弱化任务</strong>，例如：将图像描述中一对多映射简化为 VQA（<u>给机器一张图片和一个开放式的的自然语言问题，要求机器输出自然语言答案，答案可以是以下任何形式：短语、单词、 (yes/no)、从几个可能的答案中选择正确答案。 VQA 是一个典型的多模态问题，计算机需要同时学会理解图像和文字。</u>）中一对一的映射，也是解决评估困境的手段。</li>\n</ul>\n<h3 id=\"对齐alignment\"><a class=\"markdownIt-Anchor\" href=\"#对齐alignment\">#</a> 对齐 Alignment</h3>\n<p>​\t第三个挑战是从<strong>两种或多种不同的模态中识别（子）元素之间的直接关系</strong>。例如，我们可能希望<u>将食谱中的步骤与显示正在制作的菜肴的视频对齐</u>。为了应对这一挑战，我们需要测量不同模式之间的相似性并处理可能的长期依赖和歧义。</p>\n<p>​\t\t\t\t\t\t\t\t\t\t\t\t\t\t显式对齐 隐式对齐</p>\n<p><img src=\"https://oss.imzhanghao.com/img/202211051433591.png\" alt=\"Alignment\"></p>\n<h4 id=\"显式对齐\"><a class=\"markdownIt-Anchor\" href=\"#显式对齐\">#</a> 显式对齐</h4>\n<p>​\t如果模型的<strong>主要目标是对齐来自两个或多个模态的子元素</strong>，那么我们将其分类为执行显式对齐。显式对齐的一个重要工作是<strong>相似性度量</strong>。大多数方法都依赖于度量不同模态的子组件之间的相似性作为基本构建块。</p>\n<p><img src=\"https://oss.imzhanghao.com/img/202211071349090.png\" alt=\"显式对齐\"></p>\n<p>包括无监督和弱监督的方法：</p>\n<ul>\n<li><strong>无监督对齐</strong>：给定两个模态的数据作为输入，希望模型实现子元素的对齐，但是训练数据没有 “对齐结果” 的标注，模型需要同时学习相似度度量和对齐方式。</li>\n<li><strong>有监督对齐</strong>：有监督方法存在标注，可训练模型学习相似度度量。</li>\n</ul>\n<h4 id=\"隐式对齐\"><a class=\"markdownIt-Anchor\" href=\"#隐式对齐\">#</a> 隐式对齐</h4>\n<p>​\t隐式对齐<strong>用作另一个任务的中间 (通常是潜在的) 步骤。</strong> 这允许在许多任务中有更好的表现，包括语音识别、机器翻译、媒体描述和视觉问题回答。这些模型不显式地对齐数据，也不依赖于监督对齐示例，而是学习如何在模型训练期间潜在地对齐数据。</p>\n<p><img src=\"https://oss.imzhanghao.com/img/202211071428784.png\" alt=\"隐式对齐\"></p>\n<h3 id=\"融合fusion\"><a class=\"markdownIt-Anchor\" href=\"#融合fusion\">#</a> 融合 Fusion</h3>\n<p>​\t第四个挑战是<strong>结合来自两个或多个模态的信息</strong>来执行<u>预测</u>。例如，对于视听语音识别，将嘴唇运动的视觉描述与语音信号融合以预测口语。来自不同模态的信息可能具有不同的预测能力和噪声拓扑，并且可能在至少一种模态中丢失数据。</p>\n<p>​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t模型无关的方法</p>\n<p><img src=\"https://oss.imzhanghao.com/img/202211051435164.png\" alt=\"Fusion\"></p>\n<h4 id=\"模型无关的方法\"><a class=\"markdownIt-Anchor\" href=\"#模型无关的方法\">#</a> 模型无关的方法</h4>\n<p>​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t基于模型的方法</p>\n<p><img src=\"https://oss.imzhanghao.com/img/202211051436546.png\" alt=\"Fusion\"></p>\n<h4 id=\"基于模型的方法\"><a class=\"markdownIt-Anchor\" href=\"#基于模型的方法\">#</a> 基于模型的方法</h4>\n<h3 id=\"协同学习co-learning\"><a class=\"markdownIt-Anchor\" href=\"#协同学习co-learning\">#</a> 协同学习 Co-learning</h3>\n<p>​\t第五个挑战是在模态的表示和它们的预测模型之间转移知识。协同学习探索了<strong>如何从一种模态中学习的知识帮助在不同模态上训练的计算模型</strong>（<u>使用一个资源丰富的模态信息来辅助另一个资源相对贫瘠的模态进行学习</u>）。当其中一种模式的资源有限（例如，带注释的数据）时，这一挑战尤其重要。辅助模态（helper modality）通常只参与模型的训练过程，并不参与模型\t的测试使用过程</p>\n<p><img src=\"https://oss.imzhanghao.com/img/202211051437074.png\" alt=\"Co-learning\"></p>\n<h4 id=\"并行\"><a class=\"markdownIt-Anchor\" href=\"#并行\">#</a> 并行</h4>\n<p>​\t需要训练数据集，其中来自一种模态的观察结果与来自其他模态的观察结果直接相关，例如在一个视听语音数据集中，视频和语音样本来自同一个说话者。</p>\n<h4 id=\"非并行\"><a class=\"markdownIt-Anchor\" href=\"#非并行\">#</a> 非并行</h4>\n<p>​\t不需要来自不同模式的观察结果之间的直接联系，通常通过使用类别重叠来实现共同学习，例如，在零样本学习中，使用来自 Wikipedia 的纯文本数据集扩展传统的视觉对象识别数据集以改进视觉对象识别的泛化能力。</p>\n<h4 id=\"混合\"><a class=\"markdownIt-Anchor\" href=\"#混合\">#</a> 混合</h4>\n<p>​\t通过共享模式或数据集桥接</p>\n<h2 id=\"sota模型-clip\"><a class=\"markdownIt-Anchor\" href=\"#sota模型-clip\">#</a> SOTA 模型 - CLIP</h2>\n<p>​\t<strong>CLIP</strong>，全称 Contrastive Language-Image Pre-training，是 OpenAI 最新的一篇 NLP 和 CV 结合的<u>多模态</u>的工作，在多模态领域迈出了重要的一步。</p>\n<p><img src=\"https://oss.imzhanghao.com/img/202211081504107.png\" alt=\"CLIP Zero shot\"></p>\n<p>​\t\t\tCLIP 主要的贡献就是<u>利用无监督的文本信息，作为监督信号来学习视觉特征</u>。</p>\n",
            "tags": [
                "MultiModal Learning"
            ]
        },
        {
            "id": "http://aer0liteee.github.io/post/33e09c9c.html",
            "url": "http://aer0liteee.github.io/post/33e09c9c.html",
            "title": "GNN-summary",
            "date_published": "2023-07-05T09:30:02.000Z",
            "content_html": "<h1 id=\"gnn\"><a class=\"markdownIt-Anchor\" href=\"#gnn\">#</a> GNN</h1>\n<h4 id=\"应用领域\"><a class=\"markdownIt-Anchor\" href=\"#应用领域\">#</a> 应用领域</h4>\n<ul>\n<li></li>\n</ul>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">场景分析与问题推理、推荐系统、欺诈检测、知识图谱、道路交通、自动驾驶、化学医疗场景......</span><br></pre></td></tr></table></figure>\n<h4 id=\"图基本模块定义\"><a class=\"markdownIt-Anchor\" href=\"#图基本模块定义\">#</a> 图基本模块定义</h4>\n<ul>\n<li>\n<p><img src=\"https://pic.imgdb.cn/item/64aa899f1ddac507cc6b8006.png\" alt=\"\"></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">GNN 又称图神经网络，是一种直接作用于图结构的神经网络，我们可以把图中的每一个结点 V 当作个体对象，而每一条边 E 当作个体与个体间的某种联系，所有结点组成的关系网就是最后的图 U</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"邻接矩阵的定义\"><a class=\"markdownIt-Anchor\" href=\"#邻接矩阵的定义\">#</a> 邻接矩阵的定义</h4>\n<ul>\n<li>\n<p><img src=\"https://pic.imgdb.cn/item/64aa899f1ddac507cc6b808d.png\" alt=\"\"></p>\n<blockquote>\n<ul>\n<li>用于表示结点之间相邻的情况，由于图的稀疏性，因此一般的邻接矩阵不是一个 N*N 的矩阵，而保留了 **(source,target)** 的形式，如 [1,0] 则表示起点为 1 终点为 0。</li>\n<li>每个点通过与它相邻的<strong>邻居</strong>来进行<strong>更新</strong>，更新的方式可以自己设置。</li>\n</ul>\n</blockquote>\n</li>\n</ul>\n<h4 id=\"适用规则\"><a class=\"markdownIt-Anchor\" href=\"#适用规则\">#</a> 适用规则</h4>\n<ul>\n<li></li>\n</ul>\n  <figure class=\"highlight plaintext\"><table><tr><td class=\"code\"><pre><span class=\"line\">GNN主要用于解决输入数据不规则的时候，由于图像和文本任务中输入格式很固定，因此图模型并不常用，图网络和其他的神经网络类似都是需要进行特征提取</span><br></pre></td></tr></table></figure>\n<h4 id=\"消息传递方法计算\"><a class=\"markdownIt-Anchor\" href=\"#消息传递方法计算\">#</a> 消息传递方法计算</h4>\n<ul>\n<li>\n<p>每个点的特征该如何更新？</p>\n<ul>\n<li>\n<p>考虑<strong>自身</strong>的特征与<strong>邻居</strong>的特征。</p>\n</li>\n<li>\n<p><img src=\"https://pic.imgdb.cn/item/64aa89a01ddac507cc6b811e.png\" alt=\"\"></p>\n</li>\n<li>\n<p><img src=\"https://pic.imgdb.cn/item/64aa89a01ddac507cc6b8182.png\" alt=\"\"></p>\n<blockquote>\n<p>​\t\t\t\t\t自身特征：<strong>h/x</strong>\t可学习参数 (相连边的权值)：<strong>W</strong></p>\n</blockquote>\n</li>\n</ul>\n</li>\n<li>\n<p>特征更新的方法有很多，可以根据任务自己设置</p>\n<ul>\n<li><img src=\"https://pic.imgdb.cn/item/64aa89a01ddac507cc6b814c.png\" alt=\"\"></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"多层gcn的作用\"><a class=\"markdownIt-Anchor\" href=\"#多层gcn的作用\">#</a> 多层 GCN 的作用</h4>\n<ul>\n<li>\n<p>GCN 可以有多层（本质即更新各部分的特征）</p>\n<p><img src=\"https://pic.imgdb.cn/item/64aa89f01ddac507cc6c55e0.png\" alt=\"\"></p>\n</li>\n<li>\n<p>GNN 可以设置为多层结构时的<strong>输入</strong>和<strong>输出</strong>都是特征，邻接矩阵不会改变，但每个点上面的特征会发生改变。多层的 GNN 会包含更多的邻居，相当于此时的 **“感受野”**（<u>卷积神经网络名词，可理解为接触到的全局的信息范围）</u><strong>增大</strong>，当每个点具有全局的特征时，此时类似于 transformer 的形式。</p>\n</li>\n<li>\n<h5 id=\"输出特征的作用\"><a class=\"markdownIt-Anchor\" href=\"#输出特征的作用\">#</a> 输出特征的作用</h5>\n<ul>\n<li>各个点 / 边特征组合后可以进行图分类…</li>\n</ul>\n</li>\n<li>\n<h5 id=\"为什么要做多层gcn\"><a class=\"markdownIt-Anchor\" href=\"#为什么要做多层gcn\">#</a> 为什么要做多层 GCN？</h5>\n<ul>\n<li>可以使结点具有<strong>全局的特征</strong>，GCN 主要聚合邻结点的信息，对于任意一个结点，结点特征每迭代依次，就聚合了更高阶的邻结点的信息。随着 GCN 层数的增加，结点的聚合半径（最高邻居结点的阶数）也变大，一旦达到某个阈值，该结点覆盖全图结点。</li>\n<li><strong>但是</strong>，如果层数很多，每个结点覆盖的结点都会收敛到全图，这就导致每个结点的局部网络结构的多样性大大降低，对于结点自身特征的学习反而不好。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"gcn基本模型概述\"><a class=\"markdownIt-Anchor\" href=\"#gcn基本模型概述\">#</a> GCN 基本模型概述</h4>\n<ul>\n<li>适合做<strong>半监督任务</strong>，用某个结点的少量数据也能进行训练</li>\n</ul>\n<h4 id=\"图卷积的基本计算方法\"><a class=\"markdownIt-Anchor\" href=\"#图卷积的基本计算方法\">#</a> 图卷积的基本计算方法</h4>\n<ul>\n<li>\n<p>GCN 基本思想：</p>\n<p>​\t<strong>消息传递 / 聚合</strong>，即<u>平均其自身与邻居特征后传入神经网络</u>（下图橙色结点为例）。</p>\n<p><img src=\"https://pic.imgdb.cn/item/64aa89f11ddac507cc6c5660.png\" alt=\"\"></p>\n</li>\n<li>\n<p>网络层数：</p>\n<p>​    GCN 可以做多层，但一般浅做 2、3 层较合适 (6 个人认识全世界理论)，不会很多层</p>\n<p><img src=\"https://pic.imgdb.cn/item/64aa89f11ddac507cc6c5759.png\" alt=\"\"></p>\n<p>​                                                 <u>最后得到每个点的特征向量</u></p>\n</li>\n<li>\n<p>图中基本组成：</p>\n<ul>\n<li>\n<p><strong>G</strong>—— 图</p>\n</li>\n<li>\n<p><strong>A</strong>—— 邻接矩阵</p>\n</li>\n<li>\n<p><strong>D</strong>—— 各个结点</p>\n</li>\n<li>\n<p><strong>F</strong>—— 每个结点的特征</p>\n<p><img src=\"https://pic.imgdb.cn/item/64aa89f11ddac507cc6c582c.png\" alt=\"\"></p>\n</li>\n</ul>\n</li>\n<li>\n<p>特征计算方法：</p>\n<ul>\n<li><strong>矩阵乘法</strong></li>\n<li><img src=\"https://pic.imgdb.cn/item/64aa89f21ddac507cc6c5915.png\" alt=\"\"></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"邻接的矩阵的变换\"><a class=\"markdownIt-Anchor\" href=\"#邻接的矩阵的变换\">#</a> 邻接的矩阵的变换</h4>\n<ul>\n<li>考虑自身（将度矩阵考虑进去）</li>\n<li>左乘对<strong>行</strong>做<u>归一化</u>操作 + 右乘对<strong>列</strong>做<u>归一化</u>操作（归一化：简化计算的操作）</li>\n</ul>\n<p>​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t大致想法（下图）</p>\n<ul>\n<li><img src=\"https://pic.imgdb.cn/item/64aa8a1e1ddac507cc6ccd3f.png\" alt=\"\"></li>\n</ul>\n<h4 id=\"ugcn基本原理定义u\"><a class=\"markdownIt-Anchor\" href=\"#ugcn基本原理定义u\">#</a> <u>GCN 基本原理 / 定义</u></h4>\n<ul>\n<li>\n<p><img src=\"https://pic.imgdb.cn/item/64aa8a1e1ddac507cc6cce0d.png\" alt=\"\"></p>\n<ul>\n<li><strong>ReLU</strong>，全称为：Rectified Linear Unit，是一种人工神经网络中常用的激活函数，通常意义下，其指代数学中的斜坡函数，即 <u>f ( x ) = max ⁡ ( 0 , x )</u><br>\n<img src=\"https://pic.imgdb.cn/item/64aa8a1e1ddac507cc6ccf50.png\" alt=\"\"></li>\n</ul>\n</li>\n<li>\n<p>GCN 层数</p>\n<ul>\n<li>在多个图数据集中，都可以发现两三层比较合适，多反而差了。</li>\n<li><img src=\"https://pic.imgdb.cn/item/64aa8a1f1ddac507cc6cd107.png\" alt=\"\"></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"pytorch-geometric工具包安装与配置方法略\"><a class=\"markdownIt-Anchor\" href=\"#pytorch-geometric工具包安装与配置方法略\">#</a> PyTorch Geometric 工具包安装与配置方法（略）</h4>\n<ul>\n<li>\n<p><a href=\"https://www.bilibili.com/video/BV1j8411876K?p=12&amp;vd_source=d1abfb72c73986bf3b64ed4a087cdf09%EF%BC%88\">https://www.bilibili.com/video/BV1j8411876K?p=12&amp;vd_source=d1abfb72c73986bf3b64ed4a087cdf09（</a><u>Pytorch Gepmetric</u>）</p>\n</li>\n<li>\n<p><a href=\"https://blog.csdn.net/pointer_onlysoul/article/details/121354353?utm_medium=distribute.pc_relevant.none-task-blog-2\">https://blog.csdn.net/pointer_onlysoul/article/details/121354353?utm_medium=distribute.pc_relevant.none-task-blog-2</a><sub>default</sub>baidujs_baidulandingword~default-0-121354353-blog-109139329.235<sup>v35</sup>pc_relevant_default_base3&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=1</p>\n<p>（<u>Anaconda+PyTorch 安装（非英伟达显卡 + win10+Python3.8）</u>）</p>\n</li>\n<li>\n<p><a href=\"https://blog.csdn.net/C_chuxin/article/details/82690093\">https://blog.csdn.net/C_chuxin/article/details/82690093</a></p>\n<p>​\t\t\t\t(本<u>地 python 库与新装 Anaconda 库并存</u>)</p>\n</li>\n</ul>\n<h4 id=\"数据集与邻接矩阵格式karateclub空手道俱乐部案例\"><a class=\"markdownIt-Anchor\" href=\"#数据集与邻接矩阵格式karateclub空手道俱乐部案例\">#</a> 数据集与邻接矩阵格式（——KarateClub 空手道俱乐部案例）</h4>\n<ul>\n<li>\n<p>Graph Neural Networks</p>\n<ul>\n<li>\n<p>致力于解决<strong>不规则</strong>数据结构 (图像和文本相对格式都固定，但是社交网络与化学分子等格式肯定不是固定的)。</p>\n</li>\n<li>\n<p>GNN 模型<u>迭代更新</u>主要基于图中每个节点及其<strong>邻居</strong>的信息。</p>\n<p><img src=\"https://pic.imgdb.cn/item/64aa8a1f1ddac507cc6cd174.png\" alt=\"\"></p>\n</li>\n</ul>\n</li>\n<li>\n<p><strong>数据集</strong>: <u><strong>Zachary’s karate club network</strong></u></p>\n<ul>\n<li>该图描述了一个空手道俱乐部会员的社交关系，以 34 名会员作为节点，如果两位会员在俱乐部之外仍保持社交关系，则在节点间增加一条边。每人节点具有一个 34 维的特征向量，一共有 78 条边。在收集数据的过程中，管理人员 John A 和教练 Mr.Hi 之间产生了冲突，会员们选择了站队，一半会员跟随 Mr.Hi 成立了新俱乐部，剩下一半会员找了新教练或退出了俱乐部。</li>\n</ul>\n</li>\n<li>\n<p>代码实现：</p>\n<ul>\n<li>\n<p>获取数据集，打印基础数据指标</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> torch_geometric.datasets <span class=\"keyword\">import</span> KarateClub</span><br><span class=\"line\"></span><br><span class=\"line\">dataset = KarateClub()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Dataset: <span class=\"subst\">&#123;dataset&#125;</span>:&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;======================&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Number of graphs: <span class=\"subst\">&#123;<span class=\"built_in\">len</span>(dataset)&#125;</span>&#x27;</span>)  <span class=\"comment\"># 图的数量—1</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Number of features: <span class=\"subst\">&#123;dataset.num_features&#125;</span>&#x27;</span>) <span class=\"comment\"># 特征个数—34</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Number of classes: <span class=\"subst\">&#123;dataset.num_classes&#125;</span>&#x27;</span>)  <span class=\"comment\"># 数据种类—4</span></span><br><span class=\"line\"></span><br><span class=\"line\">Output:</span><br><span class=\"line\">    Dataset: KarateClub():</span><br><span class=\"line\">    ======================</span><br><span class=\"line\">    Number of graphs: <span class=\"number\">1</span></span><br><span class=\"line\">    Number of features: <span class=\"number\">34</span></span><br><span class=\"line\">    Number of classes: <span class=\"number\">4</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>PyTorch Geometric 中的每个图形都由单个 Data 对象表示，该对象包含描述其图形表示的所有信息。我们可以随时打印数据对象，以接收有关其属性及其形状的简短摘要：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">data = dataset[<span class=\"number\">0</span>]  <span class=\"comment\"># Get the first graph object.</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(data)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&#x27;=========================================================&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">Output:</span><br><span class=\"line\">    Data(x=[<span class=\"number\">34</span>, <span class=\"number\">34</span>], edge_index=[<span class=\"number\">2</span>, <span class=\"number\">156</span>], y=[<span class=\"number\">34</span>], train_mask=[<span class=\"number\">34</span>])</span><br><span class=\"line\">\t===========================================================</span><br><span class=\"line\">    </span><br><span class=\"line\">    该数据对象具有<span class=\"number\">4</span>个属性：</span><br><span class=\"line\">    （<span class=\"number\">1</span>）edge_index：<span class=\"string\">&quot;2+边的个数&quot;</span>，属性保存有关图连接性的信息，即每个边缘的源节点和目标节点。 </span><br><span class=\"line\">    （<span class=\"number\">2</span>）PyG进一步将节点特征称为x（为<span class=\"number\">34</span>个节点中的每个节点分配了一个<span class=\"number\">34</span>维特征向量），前面表示样本数量，后面表示特征维度。</span><br><span class=\"line\">    （<span class=\"number\">3</span>）节点标签称为y（每个节点被精确地分配为一个类别）。 </span><br><span class=\"line\">    （<span class=\"number\">4</span>）还有一个名为train_mask的附加属性，它描述了我们已经知道其社区归属的节点。</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>详细检查 edge_index 的属性</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> IPython.display <span class=\"keyword\">import</span> Javascript  </span><br><span class=\"line\">display(Javascript(<span class=\"string\">&#x27;&#x27;&#x27;google.colab.output.setIframeHeight(0, true, &#123;maxHeight: 300&#125;)&#x27;&#x27;&#x27;</span>))</span><br><span class=\"line\"> </span><br><span class=\"line\">edge_index = data.edge_index</span><br><span class=\"line\"><span class=\"built_in\">print</span>(edge_index.t())</span><br><span class=\"line\"></span><br><span class=\"line\">Output:</span><br><span class=\"line\">    &lt;IPython.core.display.Javascript <span class=\"built_in\">object</span>&gt;</span><br><span class=\"line\">tensor([[ <span class=\"number\">0</span>,  <span class=\"number\">1</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>,  <span class=\"number\">2</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>,  <span class=\"number\">3</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>,  <span class=\"number\">4</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>,  <span class=\"number\">5</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>,  <span class=\"number\">6</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>,  <span class=\"number\">7</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>,  <span class=\"number\">8</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>, <span class=\"number\">10</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>, <span class=\"number\">11</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>, <span class=\"number\">12</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>, <span class=\"number\">13</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>, <span class=\"number\">17</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>, <span class=\"number\">19</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>, <span class=\"number\">21</span>],</span><br><span class=\"line\">        [ <span class=\"number\">0</span>, <span class=\"number\">31</span>],</span><br><span class=\"line\">        ........</span><br><span class=\"line\">        [<span class=\"number\">33</span>,  <span class=\"number\">8</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>,  <span class=\"number\">9</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">13</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">14</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">15</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">18</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">19</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">20</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">22</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">23</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">26</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">27</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">28</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">29</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">30</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">31</span>],</span><br><span class=\"line\">        [<span class=\"number\">33</span>, <span class=\"number\">32</span>]])</span><br></pre></td></tr></table></figure>\n</li>\n<li>\n<p>networkx 可视化展示</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 导入使用的模块包</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> IPython.core.display_functions <span class=\"keyword\">import</span> display</span><br><span class=\"line\"><span class=\"keyword\">from</span> torch_geometric.datasets <span class=\"keyword\">import</span> KarateClub</span><br><span class=\"line\"><span class=\"keyword\">import</span> torch</span><br><span class=\"line\"><span class=\"keyword\">import</span> networkx <span class=\"keyword\">as</span> nx</span><br><span class=\"line\"><span class=\"keyword\">import</span> matplotlib.pyplot <span class=\"keyword\">as</span> plt</span><br><span class=\"line\"><span class=\"keyword\">from</span> torch_geometric.utils <span class=\"keyword\">import</span> to_networkx</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 定义最后可视化的函数</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">visualize</span>(<span class=\"params\">h, color, epoch=<span class=\"literal\">None</span>, loss=<span class=\"literal\">None</span></span>):</span><br><span class=\"line\">    plt.figure(figsize=(<span class=\"number\">7</span>, <span class=\"number\">7</span>))</span><br><span class=\"line\">    plt.xticks([])</span><br><span class=\"line\">    plt.yticks([])</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> torch.is_tensor(h):</span><br><span class=\"line\">        h = h.detach().cpu().numpy()</span><br><span class=\"line\">        plt.scatter(h[:, <span class=\"number\">0</span>], h[:, <span class=\"number\">1</span>], s=<span class=\"number\">140</span>, c=color, cmap=<span class=\"string\">&quot;Set2&quot;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> epoch <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span> <span class=\"keyword\">and</span> loss <span class=\"keyword\">is</span> <span class=\"keyword\">not</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">            plt.xlabel(<span class=\"string\">f&#x27;Epoch: <span class=\"subst\">&#123;epoch&#125;</span>, Loss: <span class=\"subst\">&#123;loss.item():<span class=\"number\">.4</span>f&#125;</span>&#x27;</span>, fontsize=<span class=\"number\">16</span>)</span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        nx.draw_networkx(G, pos=nx.spring_layout(G, seed=<span class=\"number\">42</span>), with_labels=<span class=\"literal\">False</span>,</span><br><span class=\"line\">                         node_color=color, cmap=<span class=\"string\">&quot;Set2&quot;</span>)</span><br><span class=\"line\">    plt.show()</span><br><span class=\"line\"></span><br><span class=\"line\">G = to_networkx(data, to_undirected=<span class=\"literal\">True</span>)\t<span class=\"comment\">#data上述步骤已给</span></span><br><span class=\"line\">visualize(G, color=data.y)</span><br></pre></td></tr></table></figure>\n<p>​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<u><strong>可视化</strong></u></p>\n</li>\n<li>\n<p><img src=\"https://pic.imgdb.cn/item/64aa8a441ddac507cc6d246b.png\" alt=\"\"></p>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"模型定义与训练方法\"><a class=\"markdownIt-Anchor\" href=\"#模型定义与训练方法\">#</a> 模型定义与训练方法</h4>\n<ul>\n<li>\n<p>模型定义</p>\n<ul>\n<li>\n<p>三层 GCN</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> torch</span><br><span class=\"line\"><span class=\"keyword\">from</span> torch.nn <span class=\"keyword\">import</span> Linear</span><br><span class=\"line\"><span class=\"keyword\">from</span> torch_geometric.nn <span class=\"keyword\">import</span> GCNConv</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">class</span> <span class=\"title class_\">GCN</span>(torch.nn.Module):</span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">__init__</span>(<span class=\"params\">self</span>):</span><br><span class=\"line\">        <span class=\"built_in\">super</span>(GCN, self).__init__()</span><br><span class=\"line\">        torch.manual_seed(<span class=\"number\">1234</span>)</span><br><span class=\"line\">        self.conv1 = GCNConv(dataset.num_features, <span class=\"number\">4</span>)</span><br><span class=\"line\">        self.conv2 = GCNConv(<span class=\"number\">4</span>, <span class=\"number\">4</span>)\t<span class=\"comment\"># 数字表示维度</span></span><br><span class=\"line\">        self.conv3 = GCNConv(<span class=\"number\">4</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">        self.classifier = Linear(<span class=\"number\">2</span>, dataset.num_classes)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">def</span> <span class=\"title function_\">forward</span>(<span class=\"params\">self, x, edge_index</span>):       <span class=\"comment\"># edge_index 为邻接矩阵</span></span><br><span class=\"line\">        h = self.conv1(x, edge_index)</span><br><span class=\"line\">        h = h.tanh()    <span class=\"comment\"># 双曲正切函数</span></span><br><span class=\"line\">        h = self.conv2(h, edge_index)</span><br><span class=\"line\">        h = h.tanh()</span><br><span class=\"line\">        h = self.conv3(h, edge_index)</span><br><span class=\"line\">        h = h.tanh()  <span class=\"comment\"># Final GNN embedding space.</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\"># Apply a final (linear) classifier.    全连接</span></span><br><span class=\"line\">        out = self.classifier(h)</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> out, h</span><br><span class=\"line\"></span><br><span class=\"line\">model = GCN()</span><br><span class=\"line\"><span class=\"built_in\">print</span>(model)</span><br><span class=\"line\"></span><br><span class=\"line\">Output:</span><br><span class=\"line\">    GCN(</span><br><span class=\"line\">  (conv1): GCNConv(<span class=\"number\">34</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">  (conv2): GCNConv(<span class=\"number\">4</span>, <span class=\"number\">4</span>)</span><br><span class=\"line\">  (conv3): GCNConv(<span class=\"number\">4</span>, <span class=\"number\">2</span>)</span><br><span class=\"line\">  (classifier): Linear(in_features=<span class=\"number\">2</span>, out_features=<span class=\"number\">4</span>, bias=<span class=\"literal\">True</span>)</span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li>\n<p>输出特征展示</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\">_, h = model(data.x, data.edge_index)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">f&#x27;Embedding shape: <span class=\"subst\">&#123;<span class=\"built_in\">list</span>(h.shape)&#125;</span>&#x27;</span>)</span><br><span class=\"line\">visualize(h, color=data.y)</span><br></pre></td></tr></table></figure>\n<p>​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<u><strong>可视化</strong></u></p>\n<p><img src=\"https://pic.imgdb.cn/item/64aa8a441ddac507cc6d24ec.png\" alt=\"\"></p>\n</li>\n<li>\n<p><strong>训练模型</strong>（半监督，semi—supervised）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> time</span><br><span class=\"line\"><span class=\"keyword\">from</span> IPython.display <span class=\"keyword\">import</span> Javascript  <span class=\"comment\"># Restrict height of output cell.</span></span><br><span class=\"line\"></span><br><span class=\"line\">display(Javascript(<span class=\"string\">&#x27;&#x27;&#x27;google.colab.output.setIframeHeight(0, true, &#123;maxHeight: 430&#125;)&#x27;&#x27;&#x27;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">criterion = torch.nn.CrossEntropyLoss()  <span class=\"comment\"># Define loss criterion.</span></span><br><span class=\"line\">optimizer = torch.optim.Adam(model.parameters(), lr=<span class=\"number\">0.01</span>)  <span class=\"comment\"># Define optimizer.</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">train</span>(<span class=\"params\">data</span>):</span><br><span class=\"line\">    optimizer.zero_grad()  <span class=\"comment\"># Clear gradients.</span></span><br><span class=\"line\">    out, h = model(data.x, data.edge_index)  <span class=\"comment\"># Perform a single forward pass.</span></span><br><span class=\"line\">    loss = criterion(out[data.train_mask],</span><br><span class=\"line\">                     data.y[data.train_mask])  <span class=\"comment\"># Compute the loss solely based on the training nodes.</span></span><br><span class=\"line\">    loss.backward()  <span class=\"comment\"># Derive gradients.</span></span><br><span class=\"line\">    optimizer.step()  <span class=\"comment\"># Update parameters based on gradients.</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> loss, h</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> epoch <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">401</span>):</span><br><span class=\"line\">    loss, h = train(data)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> epoch % <span class=\"number\">10</span> == <span class=\"number\">0</span>:</span><br><span class=\"line\">        visualize(h, color=data.y, epoch=epoch, loss=loss)</span><br><span class=\"line\">        time.sleep(<span class=\"number\">0.3</span>)</span><br></pre></td></tr></table></figure>\n<p>​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t<strong><u>可视化</u></strong></p>\n<p><img src=\"https://pic.imgdb.cn/item/64aa8a451ddac507cc6d26b7.png\" alt=\"\"></p>\n<p><img src=\"https://pic.imgdb.cn/item/64aa8a461ddac507cc6d27a9.png\" alt=\"\"></p>\n</li>\n</ul>\n",
            "tags": [
                "GNN"
            ]
        }
    ]
}